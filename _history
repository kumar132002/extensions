{"entries":[{"timestamp":1721714043465,"editorVersion":"7.0.9","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"d\"\n    ]"],[1,",\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":214,"start2":214,"length1":11,"length2":42}]}]},{"timestamp":1721714047260,"editorVersion":"7.0.9","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"20\" y=\"20\""],[0,"></b"]],"start1":67,"start2":67,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":23,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   ]"],[-1,",\n    \"preferredEditor\": \"blocksprj\""],[0,"\n}\n"]],"start1":218,"start2":218,"length1":43,"length2":7}]}]},{"timestamp":1721715342395,"editorVersion":"7.0.9","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[1,"2"],[0,"0\" y=\""],[1,"2"],[0,"0\"><"]],"start1":104,"start2":104,"length1":14,"length2":16},{"diffs":[[0,"x=\"2"],[-1,"0"],[1,"2"],[0,"5\" y=\""],[1,"2"],[0,"0\"><"]],"start1":156,"start2":156,"length1":15,"length2":16}]}]},{"timestamp":1721715350638,"editorVersion":"7.0.9","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ne\":"],[-1," \"*\",\n        \"servo\":"],[0," \"*\""]],"start1":124,"start2":124,"length1":30,"length2":8}]}]},{"timestamp":1721716862146,"editorVersion":"7.0.9","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":262,"start2":262,"length1":17,"length2":21}]}]},{"timestamp":1721717273721,"editorVersion":"7.0.9","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":111}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"namespace mbit_Display {\n\n    export enum enColor {\n\n        //% blockId=\"OFF\" block=\"off\"\n        OFF = 0,\n        //% blockId=\"Red\" block=\"red\"\n        Red,\n        //% blockId=\"Green\" block=\"green\"\n        Green,\n        //% blockId=\"Blue\" block=\"blue\"\n        Blue,\n        //% blockId=\"White\" block=\"white\"\n        White,\n        //% blockId=\"Cyan\" block=\"cyan\"\n        Cyan,\n        //% blockId=\"Pinkish\" block=\"magenta\"\n        Pinkish,\n        //% blockId=\"Yellow\" block=\"yellow\"\n        Yellow,\n\n    }\n    export enum enLED1 {\n\n        //% blockId=\"OFF\" block=\"off\"\n        OFF = 0,\n        //% blockId=\"ON\" block=\"on\"\n        ON = 1\n    }\n\n    //% blockId=mbit_LED1 block=\"LED1|pin %pin|value %value\"\n    //% weight=5\n    //% blockGap=8\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=1\n    export function LED1(pin: DigitalPin, value: enLED1): void {\n\n        pins.digitalWritePin(pin, value);\n\n    }\n\n    //% blockId=mbit_LED2 block=\"LED2|pin %pin|value %value\"\n    //% weight=4\n    //% blockGap=8\n    //% color=\"#C814B8\"\n    //% value.min=0 value.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=2\n    export function LED2(pin: AnalogPin, value: number): void {\n\n        pins.analogWritePin(pin, value * 1024 / 256);\n\n    }\n\n    //% blockId=mbit_BreathLED block=\"BreathLED|pin %pin\"\n    //% weight=3\n    //% blockGap=8\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=3\n    export function BreathLED(pin: AnalogPin): void {\n\n        for (let i: number = 0; i < 1023; i++) {\n            pins.analogWritePin(pin, i);\n            //basic.pause(1);\n            control.waitMicros(1000);\n        }\n        basic.pause(10);\n        for (let j: number = 1023; j > 0; j--) {\n            pins.analogWritePin(pin, j);\n            //basic.pause(1);\n            control.waitMicros(1000);\n        }\n\n    }\n\n    //% blockId=mbit_RGB block=\"RGB|pin1 %pin1|pin2 %pin2|pin3 %pin3|value1 %value1|value2 %value2|value3 %value3\"\n    //% weight=2\n    //% blockGap=8\n    //% color=\"#C814B8\"\n    //% value1.min=0 value1.max=255 value2.min=0 value2.max=255 value3.min=0 value3.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function RGB(pin1: AnalogPin, pin2: AnalogPin, pin3: AnalogPin, value1: number, value2: number, value3: number): void {\n\n        pins.analogWritePin(pin1, value1 * 1024 / 256);\n        pins.analogWritePin(pin2, value2 * 1024 / 256);\n        pins.analogWritePin(pin3, value3 * 1024 / 256);\n\n    }\n    //% blockId=mbit_RGB2 block=\"RGB|pin1 %pin1|pin2 %pin2|pin3 %pin3|value %value\"\n    //% weight=1\n    //% blockGap=8\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function RGB2(pin1: DigitalPin, pin2: DigitalPin, pin3: DigitalPin, value: enColor): void {\n\n        switch (value) {\n            case enColor.OFF: {\n                pins.digitalWritePin(pin1, 0);\n                pins.digitalWritePin(pin2, 0);\n                pins.digitalWritePin(pin3, 0);\n                break;\n            }\n            case enColor.Red: {\n                pins.digitalWritePin(pin1, 1);\n                pins.digitalWritePin(pin2, 0);\n                pins.digitalWritePin(pin3, 0);\n                break;\n            }\n            case enColor.Green: {\n                pins.digitalWritePin(pin1, 0);\n                pins.digitalWritePin(pin2, 1);\n                pins.digitalWritePin(pin3, 0);\n                break;\n            }\n            case enColor.Blue: {\n                pins.digitalWritePin(pin1, 0);\n                pins.digitalWritePin(pin2, 0);\n                pins.digitalWritePin(pin3, 1);\n                break;\n            }\n            case enColor.White: {\n                pins.digitalWritePin(pin1, 1);\n                pins.digitalWritePin(pin2, 1);\n                pins.digitalWritePin(pin3, 1);\n                break;\n            }\n            case enColor.Cyan: {\n                pins.digitalWritePin(pin1, 0);\n                pins.digitalWritePin(pin2, 1);\n                pins.digitalWritePin(pin3, 1);\n                break;\n            }\n            case enColor.Pinkish: {\n                pins.digitalWritePin(pin1, 1);\n                pins.digitalWritePin(pin2, 0);\n                pins.digitalWritePin(pin3, 1);\n                break;\n            }\n            case enColor.Yellow: {\n                pins.digitalWritePin(pin1, 1);\n                pins.digitalWritePin(pin2, 1);\n                pins.digitalWritePin(pin3, 0);\n                break;\n            }\n        }\n\n    }\n\n}\nnamespace mbit_Sensor {\n\n    export enum enVoice {\n        //% blockId=\"Voice\" block=\"sound\"\n        Voice = 0,\n        //% blockId=\"NoVoice\" block=\"silence\"\n        NoVoice = 1\n    }\n\n    export enum enIR {\n        //% blockId=\"Get\" block=\"detected\"\n        Get = 0,\n        //% blockId=\"NoVoice\" block=\"undetected\"\n        NoGet = 1\n    }\n\n\n    //% blockId=mbit_Voice_Sensor block=\"Voice_Sensor|pin %pin|value %value\"\n    //% weight=100\n    //% blockGap=10\n    //% color=\"#87CEEB\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Voice_Sensor(pin: DigitalPin, value: enVoice): boolean {\n\n        pins.setPull(pin, PinPullMode.PullUp);\n        if (pins.digitalReadPin(pin) == value) {\n            return true;\n        }\n        else {\n            return false;\n        }\n\n    }\n\n    function IR_send_38k() {\n        for (let k: number = 0; k < 8; k++) {\n            pins.digitalWritePin(DigitalPin.P9, 1);\n            control.waitMicros(13);\n            pins.digitalWritePin(DigitalPin.P9, 0);\n            control.waitMicros(13);\n        }\n    }\n    //% blockId=mbit_IR_Sensor block=\"IR_Sensor|pin %pin| |%value|obstacle\"\n    //% weight=100\n    //% blockGap=10\n    //% color=\"#87CEEB\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function IR_Sensor(pin: DigitalPin, value: enIR): boolean {\n\n        pins.setPull(pin, PinPullMode.PullUp);\n        //IR_send_38k();\n        if (pins.digitalReadPin(pin) == value) {\n            return true;\n        }\n        else {\n            return false;\n        }\n\n    }\n\n    //% blockId=mbit_IR_Send block=\"IR_Send|pin %pin\"\n    //% weight=100\n    //% blockGap=10\n    //% color=\"#87CEEB\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function IR_Send(pin: DigitalPin): void {\n\n\n        IR_send_38k();\n\n    }\n\n    //% blockId=mbit_ultrasonic block=\"Ultrasonic|Trig %Trig|Echo %Echo\"\n    //% color=\"#87CEEB\"\n    //% weight=100\n    //% blockGap=10\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Ultrasonic(Trig: DigitalPin, Echo: DigitalPin): number {\n\n        // send pulse\n        pins.setPull(Trig, PinPullMode.PullNone);\n        pins.digitalWritePin(Trig, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(Trig, 1);\n        control.waitMicros(15);\n        pins.digitalWritePin(Trig, 0);\n\n        // read pulse\n        let d = pins.pulseIn(Echo, PulseValue.High, 23200);\n        return Math.floor(d / 58);\n    }\n}\nnamespace mbit_Input {\n\n    export enum enRocker {\n        //% blockId=\"Nostate\" block=\"No\"\n        Nostate = 0,\n        //% blockId=\"Up\" block=\"up\"\n        Up,\n        //% blockId=\"Down\" block=\"down\"\n        Down,\n        //% blockId=\"Left\" block=\"left\"\n        Left,\n        //% blockId=\"Right\" block=\"right\"\n        Right,\n        //% blockId=\"Press\" block=\"press\"\n        Press\n    }\n\n    export enum enTouch {\n        //% blockId=\"NoTouch\" block=\"untouched\"\n        NoTouch = 0,\n        //% blockId=\"Touch\" block=\"touched\"\n        Touch = 1\n    }\n    export enum enButton {\n        //% blockId=\"Press\" block=\"press\"\n        Press = 0,\n        //% blockId=\"Realse\" block=\"release\"\n        Realse = 1\n    }\n\n    //% blockId=mbit_TouchPad block=\"TouchPad|pin %pin|value %value\"\n    //% weight=100\n    //% blockGap=10\n    //% color=\"#808080\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function TouchPad(pin: DigitalPin, value: enTouch): boolean {\n\n        pins.setPull(pin, PinPullMode.PullUp);\n        if (pins.digitalReadPin(pin) == value) {\n            return true;\n        }\n        else {\n            return false;\n        }\n\n    }\n    //% blockId=mbit_Rocker block=\"Rocker|VRX %pin1|VRY %pin2|SW %pin3|value %value\"\n    //% weight=100\n    //% blockGap=10\n    //% color=\"#808080\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=6\n    export function Rocker(pin1: AnalogPin, pin2: AnalogPin, pin3: DigitalPin, value: enRocker): boolean {\n\n        pins.setPull(pin3, PinPullMode.PullUp);\n        let x = pins.analogReadPin(pin1);\n        let y = pins.analogReadPin(pin2);\n        let z = pins.digitalReadPin(pin3);\n        let now_state = enRocker.Nostate;\n\n        if (x < 100) // 上\n        {\n\n            now_state = enRocker.Up;\n\n        }\n        else if (x > 700) //\n        {\n\n            now_state = enRocker.Down;\n        }\n        else  // 左右\n        {\n            if (y < 100) //右\n            {\n                now_state = enRocker.Right;\n            }\n            else if (y > 700) //左\n            {\n                now_state = enRocker.Left;\n            }\n        }\n        if (z == 0)\n            now_state = enRocker.Press;\n        if (now_state == value)\n            return true;\n        else\n            return false;\n\n    }\n\n    //% blockId=mbit_Button block=\"Button|pin %pin|value %value\"\n    //% weight=100\n    //% blockGap=10\n    //% color=\"#808080\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function Button(pin: DigitalPin, value: enButton): boolean {\n\n        pins.setPull(pin, PinPullMode.PullUp);\n        if (pins.digitalReadPin(pin) == value) {\n            return true;\n        }\n        else {\n            return false;\n        }\n\n    }\n}\nnamespace mbit_Music {\n    export enum enBuzzer {\n\n        //% blockId=\"NoBeep\" block=\"silence\"\n        NoBeep = 0,\n        //% blockId=\"Beep\" block=\"sound\"\n        Beep\n    }\n\n    //% blockId=mbit_Buzzer block=\"Buzzer|pin %pin|value %value\"\n    //% weight=100\n    //% blockGap=10 \n    //% color=\"#D2691E\"\n    //% value.min=0 value.max=1\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=8\n    export function Buzzer(pin: DigitalPin, value: enBuzzer): void {\n\n        pins.setPull(pin, PinPullMode.PullNone);\n        pins.digitalWritePin(pin, value);\n\n    }\n\n}\nnamespace mbit_Motor {\n\n    //% blockId=mbit_Fan block=\"Fan|pin %pin|speed %value\"\n    //% weight=100\n    //% blockGap=10\n    //% color=\"#0000CD\"\n    //% value.min=0 value.max=1023\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=9\n    export function Fan(pin: AnalogPin, value: number): void {\n\n        pins.analogWritePin(pin, value);\n\n    }\n\n    //% blockId=mbit_Servo block=\"Servo|pin %pin|value %value\"\n    //% weight=100\n    //% blockGap=10\n    //% color=\"#0000CD\"\n    //% value.min=0 value.max=180\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=9\n    export function Servo(pin: AnalogPin, value: number): void {\n\n        pins.servoWritePin(pin, value);\n\n    }\n\n}\nnamespace mbit_Robot {\n\n    const PCA9685_ADD = 0x41\n    const MODE1 = 0x00\n    const MODE2 = 0x01\n    const SUBADR1 = 0x02\n    const SUBADR2 = 0x03\n    const SUBADR3 = 0x04\n\n    const LED0_ON_L = 0x06\n    const LED0_ON_H = 0x07\n    const LED0_OFF_L = 0x08\n    const LED0_OFF_H = 0x09\n\n    const ALL_LED_ON_L = 0xFA\n    const ALL_LED_ON_H = 0xFB\n    const ALL_LED_OFF_L = 0xFC\n    const ALL_LED_OFF_H = 0xFD\n\n    const PRESCALE = 0xFE\n\n    let initialized = false\n    let yahStrip: neopixel.Strip;\n\n    export enum enColor {\n\n        //% blockId=\"OFF\" block=\"off\"\n        OFF = 0,\n        //% blockId=\"Red\" block=\"red\"\n        Red,\n        //% blockId=\"Green\" block=\"green\"\n        Green,\n        //% blockId=\"Blue\" block=\"blue\"\n        Blue,\n        //% blockId=\"White\" block=\"white\"\n        White,\n        //% blockId=\"Cyan\" block=\"cyan\"\n        Cyan,\n        //% blockId=\"Pinkish\" block=\"magenta\"\n        Pinkish,\n        //% blockId=\"Yellow\" block=\"yellow\"\n        Yellow,\n\n    }\n    export enum enMusic {\n\n        dadadum = 0,\n        entertainer,\n        prelude,\n        ode,\n        nyan,\n        ringtone,\n        funk,\n        blues,\n\n        birthday,\n        wedding,\n        funereal,\n        punchline,\n        baddy,\n        chase,\n        ba_ding,\n        wawawawaa,\n        jump_up,\n        jump_down,\n        power_up,\n        power_down\n    }\n    export enum enPos {\n\n        //% blockId=\"LeftState\" block=\"left state\"\n        LeftState = 0,\n        //% blockId=\"RightState\" block=\"right state\"\n        RightState = 1\n    }\n\n    export enum enLineState {\n        //% blockId=\"White\" block=\"white\"\n        White = 0,\n        //% blockId=\"Black\" block=\"black\"\n        Black = 1\n\n    }\n\n    export enum enAvoidState {\n        //% blockId=\"OBSTACLE\" block=\"with obstacles\"\n        OBSTACLE = 0,\n        //% blockId=\"NOOBSTACLE\" block=\"without obstacles\"\n        NOOBSTACLE = 1\n\n    }\n\n\n    export enum enServo {\n\n        S1 = 1,\n        S2,\n        S3\n    }\n    export enum CarState {\n        //% blockId=\"Car_Run\" block=\"forward\"\n        Car_Run = 1,\n        //% blockId=\"Car_Back\" block=\"back\"\n        Car_Back = 2,\n        //% blockId=\"Car_Left\" block=\"turn left\"\n        Car_Left = 3,\n        //% blockId=\"Car_Right\" block=\"turn right\"\n        Car_Right = 4,\n        //% blockId=\"Car_Stop\" block=\"stop\"\n        Car_Stop = 5,\n        //% blockId=\"Car_SpinLeft\" block=\"rotate left\"\n        Car_SpinLeft = 6,\n        //% blockId=\"Car_SpinRight\" block=\"rotate right\"\n        Car_SpinRight = 7\n    }\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2ccmd(addr: number, value: number) {\n        let buf2 = pins.createBuffer(1)\n        buf2[0] = value\n        pins.i2cWriteBuffer(addr, buf2)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADD, MODE1, 0x00)\n        setFreq(50);\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADD, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADD, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADD, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADD, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADD, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        if (!initialized) {\n            initPCA9685();\n        }\n        let buf3 = pins.createBuffer(5);\n        buf3[0] = LED0_ON_L + 4 * channel;\n        buf3[1] = on & 0xff;\n        buf3[2] = (on >> 8) & 0xff;\n        buf3[3] = off & 0xff;\n        buf3[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADD, buf3);\n    }\n\n\n    function Car_run(speed1: number, speed2: number) {\n\n        speed1 = speed1 * 16; // map 350 to 4096\n        speed2 = speed2 * 16;\n        if (speed1 >= 4096) {\n            speed1 = 4095\n        }\n        if (speed2 >= 4096) {\n            speed2 = 4095\n        }\n\n        setPwm(12, 0, speed1);\n        setPwm(13, 0, 0);\n\n        setPwm(15, 0, speed2);\n        setPwm(14, 0, 0);\n        //pins.digitalWritePin(DigitalPin.P16, 1);\n        // pins.analogWritePin(AnalogPin.P1, 1023-speed); //速度控制\n\n        // pins.analogWritePin(AnalogPin.P0, speed);//速度控制\n        // pins.digitalWritePin(DigitalPin.P8, 0);\n    }\n\n    function Car_back(speed1: number, speed2: number) {\n\n        speed1 = speed1 * 16; // map 350 to 4096\n        speed2 = speed2 * 16;\n        if (speed1 >= 4096) {\n            speed1 = 4095\n        }\n        if (speed2 >= 4096) {\n            speed2 = 4095\n        }\n        setPwm(12, 0, 0);\n        setPwm(13, 0, speed1);\n\n        setPwm(15, 0, 0);\n        setPwm(14, 0, speed2);\n\n        //pins.digitalWritePin(DigitalPin.P16, 0);\n        //pins.analogWritePin(AnalogPin.P1, speed); //速度控制\n\n        //pins.analogWritePin(AnalogPin.P0, 1023 - speed);//速度控制\n        //pins.digitalWritePin(DigitalPin.P8, 1);\n    }\n\n    function Car_left(speed1: number, speed2: number) {\n\n        speed1 = speed1 * 16; // map 350 to 4096\n        speed2 = speed2 * 16;\n        if (speed1 >= 4096) {\n            speed1 = 4095\n        }\n        if (speed2 >= 4096) {\n            speed2 = 4095\n        }\n\n        setPwm(12, 0, speed1);\n        setPwm(13, 0, 0);\n\n        setPwm(15, 0, speed2);\n        setPwm(14, 0, 0);\n\n        //pins.analogWritePin(AnalogPin.P0, speed);\n        //pins.digitalWritePin(DigitalPin.P8, 0);\n\n        //pins.digitalWritePin(DigitalPin.P16, 0);\n        //pins.digitalWritePin(DigitalPin.P1, 0);\n    }\n\n    function Car_right(speed1: number, speed2: number) {\n\n        speed1 = speed1 * 16; // map 350 to 4096\n        speed2 = speed2 * 16;\n        if (speed1 >= 4096) {\n            speed1 = 4095\n        }\n        if (speed2 >= 4096) {\n            speed2 = 4095\n        }\n\n        setPwm(12, 0, speed1);\n        setPwm(13, 0, 0);\n\n        setPwm(15, 0, speed2);\n        setPwm(14, 0, 0);\n        //pins.digitalWritePin(DigitalPin.P0, 0);\n        //pins.digitalWritePin(DigitalPin.P8, 0);\n\n        //pins.digitalWritePin(DigitalPin.P16, 1);\n        // pins.analogWritePin(AnalogPin.P1, 1023 - speed);\n    }\n\n    function Car_stop() {\n\n        setPwm(12, 0, 0);\n        setPwm(13, 0, 0);\n\n        setPwm(15, 0, 0);\n        setPwm(14, 0, 0);\n        //pins.digitalWritePin(DigitalPin.P0, 0);\n        //pins.digitalWritePin(DigitalPin.P8, 0);\n        //pins.digitalWritePin(DigitalPin.P16, 0);\n        //pins.digitalWritePin(DigitalPin.P1, 0);\n    }\n\n    function Car_spinleft(speed1: number, speed2: number) {\n\n        speed1 = speed1 * 16; // map 350 to 4096\n        speed2 = speed2 * 16;\n        if (speed1 >= 4096) {\n            speed1 = 4095\n        }\n        if (speed2 >= 4096) {\n            speed2 = 4095\n        }\n\n        setPwm(12, 0, 0);\n        setPwm(13, 0, speed1);\n\n        setPwm(15, 0, speed2);\n        setPwm(14, 0, 0);\n\n        //pins.analogWritePin(AnalogPin.P0, speed);\n        //pins.digitalWritePin(DigitalPin.P8, 0);\n\n        //pins.digitalWritePin(DigitalPin.P16, 0);\n        //pins.analogWritePin(AnalogPin.P1, speed);\n    }\n\n    function Car_spinright(speed1: number, speed2: number) {\n\n        speed1 = speed1 * 16; // map 350 to 4096\n        speed2 = speed2 * 16;\n        if (speed1 >= 4096) {\n            speed1 = 4095\n        }\n        if (speed2 >= 4096) {\n            speed2 = 4095\n        }\n        setPwm(12, 0, speed1);\n        setPwm(13, 0, 0);\n\n        setPwm(15, 0, 0);\n        setPwm(14, 0, speed2);\n        //pins.analogWritePin(AnalogPin.P0, 1023-speed);\n        //pins.digitalWritePin(DigitalPin.P8, 1);\n\n        //pins.digitalWritePin(DigitalPin.P16, 1);\n        //pins.analogWritePin(AnalogPin.P1, 1023-speed);\n\n    }\n\n    /**\n     * *****************************************************************\n     * @param index\n     */\n    //% blockId=mbit_RGB_Car_Big2 block=\"RGB_Car_Big2|value %value\"\n    //% weight=101\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function RGB_Car_Big2(value: enColor): void {\n\n        switch (value) {\n            case enColor.OFF: {\n                setPwm(0, 0, 0);\n                setPwm(1, 0, 0);\n                setPwm(2, 0, 0);\n                break;\n            }\n            case enColor.Red: {\n                setPwm(0, 0, 4095);\n                setPwm(1, 0, 0);\n                setPwm(2, 0, 0);\n                break;\n            }\n            case enColor.Green: {\n                setPwm(0, 0, 0);\n                setPwm(1, 0, 4095);\n                setPwm(2, 0, 0);\n                break;\n            }\n            case enColor.Blue: {\n                setPwm(0, 0, 0);\n                setPwm(1, 0, 0);\n                setPwm(2, 0, 4095);\n                break;\n            }\n            case enColor.White: {\n                setPwm(0, 0, 4095);\n                setPwm(1, 0, 4095);\n                setPwm(2, 0, 4095);\n                break;\n            }\n            case enColor.Cyan: {\n                setPwm(0, 0, 0);\n                setPwm(1, 0, 4095);\n                setPwm(2, 0, 4095);\n                break;\n            }\n            case enColor.Pinkish: {\n                setPwm(0, 0, 4095);\n                setPwm(1, 0, 0);\n                setPwm(2, 0, 4095);\n                break;\n            }\n            case enColor.Yellow: {\n                setPwm(0, 0, 4095);\n                setPwm(1, 0, 4095);\n                setPwm(2, 0, 0);\n                break;\n            }\n        }\n    }\n    //% blockId=mbit_RGB_Car_Big block=\"RGB_Car_Big|value1 %value1|value2 %value2|value3 %value3\"\n    //% weight=100\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% value1.min=0 value1.max=255 value2.min=0 value2.max=255 value3.min=0 value3.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function RGB_Car_Big(value1: number, value2: number, value3: number): void {\n\n        let R = value1 * 16;\n        let G = value2 * 16;\n        let B = value3 * 16;\n\n        if (R > 4096)\n            R = 4095;\n        if (G > 4096)\n            G = 4095;\n        if (B > 4096)\n            B = 4095;\n\n        setPwm(0, 0, R);\n        setPwm(1, 0, G);\n        setPwm(2, 0, B);\n\n    }\n\n    //% blockId=mbit_RGB_Car_Program block=\"RGB_Car_Program\"\n    //% weight=99\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function RGB_Car_Program(): neopixel.Strip {\n\n        if (!yahStrip) {\n            yahStrip = neopixel.create(DigitalPin.P16, 3, NeoPixelMode.RGB);\n        }\n        return yahStrip;\n    }\n\n\n    //% blockId=mbit_ultrasonic_car block=\"ultrasonic return distance(cm)\"\n    //% color=\"#006400\"\n    //% weight=98\n    //% blockGap=10\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Ultrasonic_Car(): number {\n\n        // send pulse\n        let list: Array<number> = [0, 0, 0, 0, 0];\n        for (let l = 0; l < 5; l++) {\n            pins.setPull(DigitalPin.P14, PinPullMode.PullNone);\n            pins.digitalWritePin(DigitalPin.P14, 0);\n            control.waitMicros(2);\n            pins.digitalWritePin(DigitalPin.P14, 1);\n            control.waitMicros(15);\n            pins.digitalWritePin(DigitalPin.P14, 0);\n\n            let e = pins.pulseIn(DigitalPin.P15, PulseValue.High, 43200);\n            list[l] = Math.floor(e / 40)\n        }\n        list.sort();\n        let length = (list[1] + list[2] + list[3]) / 3;\n        return Math.floor(length);\n    }\n\n    //% blockId=mbit_Music_Car block=\"Music_Car|%index\"\n    //% weight=97\n    //% blockGap=10\n    //% color=\"#006400\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Music_Car(index: enMusic): void {\n        switch (index) {\n            case enMusic.dadadum: music.beginMelody(music.builtInMelody(Melodies.Dadadadum), MelodyOptions.Once); break;\n            case enMusic.birthday: music.beginMelody(music.builtInMelody(Melodies.Birthday), MelodyOptions.Once); break;\n            case enMusic.entertainer: music.beginMelody(music.builtInMelody(Melodies.Entertainer), MelodyOptions.Once); break;\n            case enMusic.prelude: music.beginMelody(music.builtInMelody(Melodies.Prelude), MelodyOptions.Once); break;\n            case enMusic.ode: music.beginMelody(music.builtInMelody(Melodies.Ode), MelodyOptions.Once); break;\n            case enMusic.nyan: music.beginMelody(music.builtInMelody(Melodies.Nyan), MelodyOptions.Once); break;\n            case enMusic.ringtone: music.beginMelody(music.builtInMelody(Melodies.Ringtone), MelodyOptions.Once); break;\n            case enMusic.funk: music.beginMelody(music.builtInMelody(Melodies.Funk), MelodyOptions.Once); break;\n            case enMusic.blues: music.beginMelody(music.builtInMelody(Melodies.Blues), MelodyOptions.Once); break;\n            case enMusic.wedding: music.beginMelody(music.builtInMelody(Melodies.Wedding), MelodyOptions.Once); break;\n            case enMusic.funereal: music.beginMelody(music.builtInMelody(Melodies.Funeral), MelodyOptions.Once); break;\n            case enMusic.punchline: music.beginMelody(music.builtInMelody(Melodies.Punchline), MelodyOptions.Once); break;\n            case enMusic.baddy: music.beginMelody(music.builtInMelody(Melodies.Baddy), MelodyOptions.Once); break;\n            case enMusic.chase: music.beginMelody(music.builtInMelody(Melodies.Chase), MelodyOptions.Once); break;\n            case enMusic.ba_ding: music.beginMelody(music.builtInMelody(Melodies.BaDing), MelodyOptions.Once); break;\n            case enMusic.wawawawaa: music.beginMelody(music.builtInMelody(Melodies.Wawawawaa), MelodyOptions.Once); break;\n            case enMusic.jump_up: music.beginMelody(music.builtInMelody(Melodies.JumpUp), MelodyOptions.Once); break;\n            case enMusic.jump_down: music.beginMelody(music.builtInMelody(Melodies.JumpDown), MelodyOptions.Once); break;\n            case enMusic.power_up: music.beginMelody(music.builtInMelody(Melodies.PowerUp), MelodyOptions.Once); break;\n            case enMusic.power_down: music.beginMelody(music.builtInMelody(Melodies.PowerDown), MelodyOptions.Once); break;\n        }\n    }\n    //% blockId=mbit_Servo_Car block=\"Servo_Car|num %num|value %value\"\n    //% weight=96\n    //% blockGap=10\n    //% color=\"#006400\"\n    //% num.min=1 num.max=3 value.min=0 value.max=180\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=9\n    export function Servo_Car(num: enServo, value: number): void {\n\n        // 50hz: 20,000 us\n        let us = (value * 1800 / 180 + 600); // 0.6 ~ 2.4\n        let pwm = us * 4096 / 20000;\n        setPwm(num + 2, 0, pwm);\n\n    }\n\n    //% blockId=mbit_Avoid_Sensor block=\"Avoid_Sensor|value %value\"\n    //% weight=95\n    //% blockGap=10\n    //% color=\"#006400\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=12\n    export function Avoid_Sensor(value: enAvoidState): boolean {\n\n        let temp: boolean = false;\n        pins.setPull(DigitalPin.P9, PinPullMode.PullUp)\n        pins.digitalWritePin(DigitalPin.P9, 0);\n        control.waitMicros(100);\n        switch (value) {\n            case enAvoidState.OBSTACLE: {\n                serial.writeNumber(pins.analogReadPin(AnalogPin.P3))\n                if (pins.analogReadPin(AnalogPin.P3) < 800) {\n\n                    temp = true;\n                    setPwm(8, 0, 0);\n                }\n                else {\n                    temp = false;\n                    setPwm(8, 0, 4095);\n                }\n                break;\n            }\n\n            case enAvoidState.NOOBSTACLE: {\n                if (pins.analogReadPin(AnalogPin.P3) > 800) {\n\n                    temp = true;\n                    setPwm(8, 0, 4095);\n                }\n                else {\n                    temp = false;\n                    setPwm(8, 0, 0);\n                }\n                break;\n            }\n        }\n        pins.digitalWritePin(DigitalPin.P9, 1);\n        return temp;\n\n    }\n    //% blockId=mbit_Line_Sensor block=\"Line_Sensor|direct %direct|value %value\"\n    //% weight=94\n    //% blockGap=10\n    //% color=\"#006400\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=12\n    export function Line_Sensor(direct: enPos, value: enLineState): boolean {\n\n        let temp2: boolean = false;\n\n        switch (direct) {\n            case enPos.LeftState: {\n                if (pins.analogReadPin(AnalogPin.P2) < 500) {\n                    if (value == enLineState.White) {\n                        temp2 = true;\n                    }\n                    setPwm(7, 0, 4095);\n                }\n                else {\n                    if (value == enLineState.Black) {\n                        temp2 = true;\n                    }\n                    setPwm(7, 0, 0);\n                }\n                break;\n            }\n\n            case enPos.RightState: {\n                if (pins.analogReadPin(AnalogPin.P1) < 500) {\n                    if (value == enLineState.White) {\n                        temp2 = true;\n                    }\n                    setPwm(6, 0, 4095);\n                }\n                else {\n                    if (value == enLineState.Black) {\n                        temp2 = true;\n                    }\n                    setPwm(6, 0, 0);\n                }\n                break;\n            }\n        }\n        return temp2;\n\n    }\n    //% blockId=mbit_CarCtrl block=\"CarCtrl|%index\"\n    //% weight=93\n    //% blockGap=10\n    //% color=\"#006400\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=10\n    export function CarCtrl(index: CarState): void {\n        switch (index) {\n            case CarState.Car_Run: Car_run(255, 255); break;\n            case CarState.Car_Back: Car_back(255, 255); break;\n            case CarState.Car_Left: Car_left(0, 255); break;\n            case CarState.Car_Right: Car_right(255, 0); break;\n            case CarState.Car_Stop: Car_stop(); break;\n            case CarState.Car_SpinLeft: Car_spinleft(255, 255); break;\n            case CarState.Car_SpinRight: Car_spinright(255, 255); break;\n        }\n    }\n    //% blockId=mbit_CarCtrlSpeed block=\"CarCtrlSpeed|%index|speed %speed\"\n    //% weight=92\n    //% blockGap=10\n    //% speed.min=0 speed.max=255\n    //% color=\"#006400\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=10\n    export function CarCtrlSpeed(index: CarState, speed: number): void {\n        switch (index) {\n            case CarState.Car_Run: Car_run(speed, speed); break;\n            case CarState.Car_Back: Car_back(speed, speed); break;\n            case CarState.Car_Left: Car_left(0, speed); break;\n            case CarState.Car_Right: Car_right(speed, 0); break;\n            case CarState.Car_Stop: Car_stop(); break;\n            case CarState.Car_SpinLeft: Car_spinleft(speed, speed); break;\n            case CarState.Car_SpinRight: Car_spinright(speed, speed); break;\n        }\n    }\n    //% blockId=mbit_CarCtrlSpeed2 block=\"CarCtrlSpeed2|%index|speed1 %speed1|speed2 %speed2\"\n    //% weight=91\n    //% blockGap=10\n    //% speed1.min=0 speed1.max=255 speed2.min=0 speed2.max=255\n    //% color=\"#006400\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=10\n    export function CarCtrlSpeed2(index: CarState, speed1: number, speed2: number): void {\n        switch (index) {\n            case CarState.Car_Run: Car_run(speed1, speed2); break;\n            case CarState.Car_Back: Car_back(speed1, speed2); break;\n            case CarState.Car_Left: Car_left(0, speed2); break;\n            case CarState.Car_Right: Car_right(speed1, 0); break;\n            case CarState.Car_Stop: Car_stop(); break;\n            case CarState.Car_SpinLeft: Car_spinleft(speed1, speed2); break;\n            case CarState.Car_SpinRight: Car_spinright(speed1, speed2); break;\n        }\n    }\n}\nnamespace SuperBit {\n\n    const PCA9685_ADD = 0x40\n    const MODE1 = 0x00\n    const MODE2 = 0x01\n    const SUBADR1 = 0x02\n    const SUBADR2 = 0x03\n    const SUBADR3 = 0x04\n\n    const LED0_ON_L = 0x06\n    const LED0_ON_H = 0x07\n    const LED0_OFF_L = 0x08\n    const LED0_OFF_H = 0x09\n\n    const ALL_LED_ON_L = 0xFA\n    const ALL_LED_ON_H = 0xFB\n    const ALL_LED_OFF_L = 0xFC\n    const ALL_LED_OFF_H = 0xFD\n\n    const PRESCALE = 0xFE\n\n    const STP_CHA_L = 2047\n    const STP_CHA_H = 4095\n\n    const STP_CHB_L = 1\n    const STP_CHB_H = 2047\n\n    const STP_CHC_L = 1023\n    const STP_CHC_H = 3071\n\n    const STP_CHD_L = 3071\n    const STP_CHD_H = 1023\n\n    let initialized = false\n    let yahStrip: neopixel.Strip;\n\n\n    export enum enMusic {\n\n        dadadum = 0,\n        entertainer,\n        prelude,\n        ode,\n        nyan,\n        ringtone,\n        funk,\n        blues,\n\n        birthday,\n        wedding,\n        funereal,\n        punchline,\n        baddy,\n        chase,\n        ba_ding,\n        wawawawaa,\n        jump_up,\n        jump_down,\n        power_up,\n        power_down\n    }\n\n\n\n    export enum enSteppers {\n        B1 = 0x1,\n        B2 = 0x2\n    }\n    export enum enPos {\n        //% blockId=\"forward\" block=\"forward\"\n        forward = 1,\n        //% blockId=\"reverse\" block=\"reverse\"\n        reverse = 2,\n        //% blockId=\"stop\" block=\"stop\"\n        stop = 3\n    }\n\n    export enum enTurns {\n        //% blockId=\"T1B4\" block=\"1/4\"\n        T1B4 = 90,\n        //% blockId=\"T1B2\" block=\"1/2\"\n        T1B2 = 180,\n        //% blockId=\"T1B0\" block=\"1\"\n        T1B0 = 360,\n        //% blockId=\"T2B0\" block=\"2\"\n        T2B0 = 720,\n        //% blockId=\"T3B0\" block=\"3\"\n        T3B0 = 1080,\n        //% blockId=\"T4B0\" block=\"4\"\n        T4B0 = 1440,\n        //% blockId=\"T5B0\" block=\"5\"\n        T5B0 = 1800\n    }\n\n    export enum enServo {\n\n        S1 = 0,\n        S2,\n        S3,\n        S4,\n        S5,\n        S6,\n        S7,\n        S8\n    }\n    export enum enMotors {\n        M1 = 8,\n        M2 = 10,\n        M3 = 12,\n        M4 = 14\n    }\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2ccmd(addr: number, value: number) {\n        let buf = pins.createBuffer(1)\n        buf[0] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADD, MODE1, 0x00)\n        setFreq(50);\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADD, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADD, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADD, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADD, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADD, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        if (!initialized) {\n            initPCA9685();\n        }\n        let buf = pins.createBuffer(5);\n        buf[0] = LED0_ON_L + 4 * channel;\n        buf[1] = on & 0xff;\n        buf[2] = (on >> 8) & 0xff;\n        buf[3] = off & 0xff;\n        buf[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADD, buf);\n    }\n\n    function setStepper(index: number, dir: boolean): void {\n        if (index == enSteppers.B1) {\n            if (dir) {\n                setPwm(11, STP_CHA_L, STP_CHA_H);\n                setPwm(9, STP_CHB_L, STP_CHB_H);\n                setPwm(10, STP_CHC_L, STP_CHC_H);\n                setPwm(8, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(8, STP_CHA_L, STP_CHA_H);\n                setPwm(10, STP_CHB_L, STP_CHB_H);\n                setPwm(9, STP_CHC_L, STP_CHC_H);\n                setPwm(11, STP_CHD_L, STP_CHD_H);\n            }\n        } else {\n            if (dir) {\n                setPwm(12, STP_CHA_L, STP_CHA_H);\n                setPwm(14, STP_CHB_L, STP_CHB_H);\n                setPwm(13, STP_CHC_L, STP_CHC_H);\n                setPwm(15, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(15, STP_CHA_L, STP_CHA_H);\n                setPwm(13, STP_CHB_L, STP_CHB_H);\n                setPwm(14, STP_CHC_L, STP_CHC_H);\n                setPwm(12, STP_CHD_L, STP_CHD_H);\n            }\n        }\n    }\n\n    function stopMotor(index: number) {\n        setPwm(index, 0, 0);\n        setPwm(index + 1, 0, 0);\n    }\n    /**\n     * *****************************************************************\n     * @param index\n     */\n    //% blockId=SuperBit_RGB_Program block=\"RGB_Program\"\n    //% weight=99\n    //% blockGap=10\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function RGB_Program(): neopixel.Strip {\n\n        if (!yahStrip) {\n            yahStrip = neopixel.create(DigitalPin.P12, 4, NeoPixelMode.RGB);\n        }\n        return yahStrip;\n    }\n\n    //% blockId=SuperBit_Music block=\"Music|%index\"\n    //% weight=98\n    //% blockGap=10\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Music(index: enMusic): void {\n        switch (index) {\n            case enMusic.dadadum: music.beginMelody(music.builtInMelody(Melodies.Dadadadum), MelodyOptions.Once); break;\n            case enMusic.birthday: music.beginMelody(music.builtInMelody(Melodies.Birthday), MelodyOptions.Once); break;\n            case enMusic.entertainer: music.beginMelody(music.builtInMelody(Melodies.Entertainer), MelodyOptions.Once); break;\n            case enMusic.prelude: music.beginMelody(music.builtInMelody(Melodies.Prelude), MelodyOptions.Once); break;\n            case enMusic.ode: music.beginMelody(music.builtInMelody(Melodies.Ode), MelodyOptions.Once); break;\n            case enMusic.nyan: music.beginMelody(music.builtInMelody(Melodies.Nyan), MelodyOptions.Once); break;\n            case enMusic.ringtone: music.beginMelody(music.builtInMelody(Melodies.Ringtone), MelodyOptions.Once); break;\n            case enMusic.funk: music.beginMelody(music.builtInMelody(Melodies.Funk), MelodyOptions.Once); break;\n            case enMusic.blues: music.beginMelody(music.builtInMelody(Melodies.Blues), MelodyOptions.Once); break;\n            case enMusic.wedding: music.beginMelody(music.builtInMelody(Melodies.Wedding), MelodyOptions.Once); break;\n            case enMusic.funereal: music.beginMelody(music.builtInMelody(Melodies.Funeral), MelodyOptions.Once); break;\n            case enMusic.punchline: music.beginMelody(music.builtInMelody(Melodies.Punchline), MelodyOptions.Once); break;\n            case enMusic.baddy: music.beginMelody(music.builtInMelody(Melodies.Baddy), MelodyOptions.Once); break;\n            case enMusic.chase: music.beginMelody(music.builtInMelody(Melodies.Chase), MelodyOptions.Once); break;\n            case enMusic.ba_ding: music.beginMelody(music.builtInMelody(Melodies.BaDing), MelodyOptions.Once); break;\n            case enMusic.wawawawaa: music.beginMelody(music.builtInMelody(Melodies.Wawawawaa), MelodyOptions.Once); break;\n            case enMusic.jump_up: music.beginMelody(music.builtInMelody(Melodies.JumpUp), MelodyOptions.Once); break;\n            case enMusic.jump_down: music.beginMelody(music.builtInMelody(Melodies.JumpDown), MelodyOptions.Once); break;\n            case enMusic.power_up: music.beginMelody(music.builtInMelody(Melodies.PowerUp), MelodyOptions.Once); break;\n            case enMusic.power_down: music.beginMelody(music.builtInMelody(Melodies.PowerDown), MelodyOptions.Once); break;\n        }\n    }\n\n    //% blockId=SuperBit_Servo block=\"Servo(180°)|num %num|value %value\"\n    //% weight=97\n    //% blockGap=10\n    //% num.min=1 num.max=4 value.min=0 value.max=180\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=20\n    export function Servo(num: enServo, value: number): void {\n\n        // 50hz: 20,000 us\n        let us = (value * 1800 / 180 + 600); // 0.6 ~ 2.4\n        let pwm = us * 4096 / 20000;\n        setPwm(num, 0, pwm);\n\n    }\n\n    //% blockId=SuperBit_Servo2 block=\"Servo(270°)|num %num|value %value\"\n    //% weight=96\n    //% blockGap=10\n    //% num.min=1 num.max=4 value.min=0 value.max=270\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=20\n    export function Servo2(num: enServo, value: number): void {\n\n        // 50hz: 20,000 us\n        let newvalue = Math.map(value, 0, 270, 0, 180);\n        let us = (newvalue * 1800 / 180 + 600); // 0.6 ~ 2.4\n        let pwm = us * 4096 / 20000;\n        setPwm(num, 0, pwm);\n\n    }\n\n    //% blockId=SuperBit_Servo3 block=\"Servo(360°)|num %num|pos %pos|value %value\"\n    //% weight=96\n    //% blockGap=10\n    //% num.min=1 num.max=4 value.min=0 value.max=90\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=20\n    export function Servo3(num: enServo, pos: enPos, value: number): void {\n\n        // 50hz: 20,000 us\n\n        if (pos == enPos.stop) {\n            let us = (86 * 1800 / 180 + 600); // 0.6 ~ 2.4\n            let pwm = us * 4096 / 20000;\n            setPwm(num, 0, pwm);\n        }\n        else if (pos == enPos.forward) { //0-90 -> 90 - 0\n            let us = ((90 - value) * 1800 / 180 + 600); // 0.6 ~ 2.4\n            let pwm = us * 4096 / 20000;\n            setPwm(num, 0, pwm);\n        }\n        else if (pos == enPos.reverse) { //0-90 -> 90 -180\n            let us = ((90 + value) * 1800 / 180 + 600); // 0.6 ~ 2.4\n            let pwm = us * 4096 / 20000;\n            setPwm(num, 0, pwm);\n        }\n\n\n\n    }\n    //% blockId=SuperBit_MotorRun block=\"Motor|%index|speed(-255~255) %speed\"\n    //% weight=93\n    //% speed.min=-255 speed.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRun(index: enMotors, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n\n        let a = index\n        let b = index + 1\n\n        if (a > 10) {\n            if (speed >= 0) {\n                setPwm(a, 0, speed)\n                setPwm(b, 0, 0)\n            } else {\n                setPwm(a, 0, 0)\n                setPwm(b, 0, -speed)\n            }\n        }\n        else {\n            if (speed >= 0) {\n                setPwm(b, 0, speed)\n                setPwm(a, 0, 0)\n            } else {\n                setPwm(b, 0, 0)\n                setPwm(a, 0, -speed)\n            }\n        }\n\n    }\n\n\n\n    //% blockId=SuperBit_MotorRunDual block=\"Motor|%motor1|speed %speed1|%motor2|speed %speed2\"\n    //% weight=92\n    //% blockGap=50\n    //% speed1.min=-255 speed1.max=255\n    //% speed2.min=-255 speed2.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=2\n    export function MotorRunDual(motor1: enMotors, speed1: number, motor2: enMotors, speed2: number): void {\n        MotorRun(motor1, speed1);\n        MotorRun(motor2, speed2);\n    }\n\n    //% blockId=SuperBit_StepperDegree block=\"Stepper Motor(28BYJ-48) |%index|degree %degree\"\n    //% weight=90\n    export function StepperDegree(index: enSteppers, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setStepper(index, degree > 0);\n        degree = Math.abs(degree);\n        basic.pause(10240 * degree / 360);\n        MotorStopAll()\n    }\n\n    //% blockId=SuperBit_MotorStopAll block=\"Motor Stop All\"\n    //% weight=91\n    //% blockGap=50\n    export function MotorStopAll(): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n\n        stopMotor(enMotors.M1);\n        stopMotor(enMotors.M2);\n        stopMotor(enMotors.M3);\n        stopMotor(enMotors.M4);\n\n    }\n\n    //% blockId=SuperBit_StepperTurn block=\"Stepper Motor(28BYJ-48) |%index|turn %turn|circle\"\n    //% weight=89\n    export function StepperTurn(index: enSteppers, turn: enTurns): void {\n        let degree = turn;\n        StepperDegree(index, degree);\n    }\n\n    //% blockId=SuperBit_StepperDual block=\"Dual Stepper Motor(Degree) |M1 %degree1| M2 %degree2\"\n    //% weight=88\n    export function StepperDual(degree1: number, degree2: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setStepper(1, degree1 > 0);\n        setStepper(2, degree2 > 0);\n        degree1 = Math.abs(degree1);\n        degree2 = Math.abs(degree2);\n        basic.pause(10240 * Math.min(degree1, degree2) / 360);\n        if (degree1 > degree2) {\n            stopMotor(enMotors.M3);\n            stopMotor(enMotors.M4);\n            basic.pause(10240 * (degree1 - degree2) / 360);\n        } else {\n            stopMotor(enMotors.M1);\n            stopMotor(enMotors.M2);\n            basic.pause(10240 * (degree2 - degree1) / 360);\n        }\n\n        MotorStopAll()\n    }\n\n    //% blockId=SuperBit_PWMOFF block=\"PWM OFF|%index\"\n    //% weight=87\n    export function PWMOFF(index: number): void {\n        setPwm(index, 0, 0);\n    }\n\n}\nnamespace TM1650 {\n\n    let COMMAND_I2C_ADDRESS = 0x24\n    let DISPLAY_I2C_ADDRESS = 0x34\n    let _SEG = [0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71];\n\n    let TM1650_CDigits = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x82, 0x21, 0x00, 0x00, 0x00, 0x00, 0x02, 0x39, 0x0F, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00,\n        0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7f, 0x6f, 0x00, 0x00, 0x00, 0x48, 0x00, 0x53,\n        0x00, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71, 0x6F, 0x76, 0x06, 0x1E, 0x00, 0x38, 0x00, 0x54, 0x3F,\n        0x73, 0x67, 0x50, 0x6D, 0x78, 0x3E, 0x00, 0x00, 0x00, 0x6E, 0x00, 0x39, 0x00, 0x0F, 0x00, 0x08,\n        0x63, 0x5F, 0x7C, 0x58, 0x5E, 0x7B, 0x71, 0x6F, 0x74, 0x02, 0x1E, 0x00, 0x06, 0x00, 0x54, 0x5C,\n        0x73, 0x67, 0x50, 0x6D, 0x78, 0x1C, 0x00, 0x00, 0x00, 0x6E, 0x00, 0x39, 0x30, 0x0F, 0x00, 0x00\n    ];\n\n    let _intensity = 3\n    let dbuf = [0, 0, 0, 0]\n    let iPosition = \"\"\n\n    /**\n     * send command to display\n     * @param is command, eg: 0\n     */\n    function cmd(c: number) {\n        pins.i2cWriteNumber(COMMAND_I2C_ADDRESS, c, NumberFormat.Int8BE)\n    }\n\n    /**\n     * send data to display\n     * @param is data, eg: 0\n     */\n    function dat(bit: number, d: number) {\n        pins.i2cWriteNumber(DISPLAY_I2C_ADDRESS + (bit % 4), d, NumberFormat.Int8BE)\n    }\n\n    /**\n     * turn on display\n     */\n    //% blockId=\"TM650_ON\" block=\"turn on display\"\n    //% weight=50 blockGap=8\n    export function on() {\n        cmd(_intensity * 16 + 1)\n    }\n\n    /**\n     * turn off display\n     */\n    //% blockId=\"TM650_OFF\" block=\"turn off display\"\n    //% weight=50 blockGap=8\n    export function off() {\n        _intensity = 0\n        cmd(0)\n    }\n\n    /**\n     * clear display content\n     */\n    //% blockId=\"TM650_CLEAR\" block=\"clear display\"\n    //% weight=40 blockGap=8\n    export function clear() {\n        dat(0, 0)\n        dat(1, 0)\n        dat(2, 0)\n        dat(3, 0)\n        dbuf = [0, 0, 0, 0]\n    }\n\n    /**\n     * show a digital in given position\n     * @param digit is number (0-15) will be shown, eg: 1\n     * @param bit is position, eg: 0\n     */\n    //% blockId=\"TM650_DIGIT\" block=\"show digit %num|at %bit\"\n    //% weight=80 blockGap=8\n    //% num.max=15 num.min=0\n    export function digit(num: number, bit: number) {\n        dbuf[bit % 4] = _SEG[num % 16]\n        dat(bit, _SEG[num % 16])\n    }\n\n    /**\n     * show a number in display\n     * @param num is number will be shown, eg: 100\n     */\n    //% blockId=\"TM650_SHOW_NUMBER\" block=\"show number %num\"\n    //% weight=100 blockGap=8\n    export function showNumber(num: number) {\n        if (num < 0) {\n            dat(0, 0x40) // '-'\n            num = -num\n        }\n        else\n            digit(Math.idiv(num, 1000) % 10, 0)\n        digit(num % 10, 3)\n        digit(Math.idiv(num, 10) % 10, 2)\n        digit(Math.idiv(num, 100) % 10, 1)\n    }\n\n\n    //% blockId=\"showSring\" block=\"show string %str\"\n    //% weight=100 blockGap=8\n    export function showSring(str: string) {\n        for (let i = 0; i < 4; i++) {\n            let a = str.charCodeAt(i) & 0x7F;\n            let dot = str.charCodeAt(i) & 0x80;\n            dbuf[i] = TM1650_CDigits[a];\n            if (a) {\n                pins.i2cWriteNumber(DISPLAY_I2C_ADDRESS + i, dbuf[i] | dot, NumberFormat.Int8BE)\n            }\n            else {\n                break;\n            }\n\n        }\n    }\n\n\n    function displayRuning(str: string, del: number): number {\n        iPosition = str;\n        showSring(iPosition);\n        basic.pause(del);\n        let l = iPosition.length;\n\n        if (l < 4) {\n            return 0;\n        }\n        else {\n            return (l - 4);\n        }\n\n    }\n\n    function displayRunningShift(): number {\n\n        if (iPosition.length <= 4) {\n            return 0;\n\n        }\n        else {\n            iPosition = iPosition.substr(1, iPosition.length - 1);\n            showSring(iPosition);\n            return (iPosition.length - 4);\n        }\n\n    }\n\n    //% blockId=\"showRunging\" block=\"scroll display %str | rolling time(ms) %del\"\n    //% weight=90 blockGap=8\n    export function showRunging(str: string, del: number) {\n        if (displayRuning(str, del)) {\n            while (displayRunningShift()) {\n                basic.pause(del);\n            }\n\n        }\n\n\n    }\n\n\n\n    /**\n     * show a number in hex format\n     * @param num is number will be shown, eg: 123\n     */\n    //% blockId=\"TM650_SHOW_HEX_NUMBER\" block=\"show hex number %num\"\n    //% weight=90 blockGap=8\n    export function showHex(num: number) {\n        if (num < 0) {\n            dat(0, 0x40) // '-'\n            num = -num\n        }\n        else\n            digit((num >> 12) % 16, 0)\n        digit(num % 16, 3)\n        digit((num >> 4) % 16, 2)\n        digit((num >> 8) % 16, 1)\n    }\n\n    /**\n     * show Dot Point in given position\n     * @param bit is positiion, eg: 0\n     * @param show is true/false, eg: true\n     */\n    //% blockId=\"TM650_SHOW_DP\" block=\"show dot point %bit|show %num\"\n    //% weight=80 blockGap=8\n    export function showDpAt(bit: number, show: boolean) {\n        if (show) dat(bit, dbuf[bit % 4] | 0x80)\n        else dat(bit, dbuf[bit % 4] & 0x7F)\n    }\n\n    /**\n     * set display intensity\n     * @param dat is intensity of the display, eg: 3\n     */\n    //% blockId=\"TM650_INTENSITY\" block=\"set intensity %dat\"\n    //% weight=70 blockGap=8\n    export function setIntensity(dat: number) {\n        if ((dat < 0) || (dat > 8))\n            return;\n        if (dat == 0)\n            off()\n        else {\n            _intensity = dat\n            cmd((dat << 4) | 0x01)\n        }\n    }\n\n    on();\n}\nnamespace Module_World_Color {\n\n    const COLOR_ADD = 0X53;\n    const COLOR_REG = 0x00;\n    const COLOR_R = 0X10;\n    const COLOR_G = 0X0D;\n    const COLOR_B = 0x13;\n\n    let initialized = false;\n    let val_red = 0;\n    let val_green = 0;\n    let val_blue = 0;\n\n    export enum enGetRGB {\n        //% blockId=\"GetValueR\" block=\"GetValueR\"\n        GetValueR = 0,\n        //% blockId=\"GetValueG\" block=\"GetValueG\"\n        GetValueG = 1,\n        //% blockId=\"GetValueB\" block=\"GetValueB\"\n        GetValueB = 2\n    }\n\n    function i2cWriteData(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2);\n        buf[0] = reg;\n        buf[1] = value;\n        pins.i2cWriteBuffer(addr, buf);\n    }\n\n    function setRegConfig(): void {\n        i2cWriteData(COLOR_ADD, COLOR_REG, 0X06);\n        i2cWriteData(COLOR_ADD, 0X04, 0X41);\n        i2cWriteData(COLOR_ADD, 0x05, 0x01);\n    }\n\n    function initColorI2C(): void {\n        setRegConfig();\n        initialized = true;\n    }\n\n    function GetRGB(): void {\n        let buff_R = pins.createBuffer(2);\n        let buff_G = pins.createBuffer(2);\n        let buff_B = pins.createBuffer(2);\n\n        pins.i2cWriteNumber(COLOR_ADD, COLOR_R, NumberFormat.UInt8BE);\n        buff_R = pins.i2cReadBuffer(COLOR_ADD, 2);\n\n        pins.i2cWriteNumber(COLOR_ADD, COLOR_G, NumberFormat.UInt8BE);\n        buff_G = pins.i2cReadBuffer(COLOR_ADD, 2);\n\n        pins.i2cWriteNumber(COLOR_ADD, COLOR_B, NumberFormat.UInt8BE);\n        buff_B = pins.i2cReadBuffer(COLOR_ADD, 2);\n\n        let Red = (buff_R[1] & 0xff) << 8 | (buff_R[0] & 0xff);\n        let Green = (buff_G[1] & 0xff) << 8 | (buff_G[0] & 0xff);\n        let Blue = (buff_B[1] & 0xff) << 8 | (buff_B[0] & 0xff);\n\n        if (Red > 4500) Red = 2300;\n        if (Green > 7600) Green = 4600;\n        if (Blue > 4600) Blue = 2700;\n\n        val_red = Math.map(Red, 0, 2300, 0, 255);\n        val_green = Math.map(Green, 0, 4600, 0, 255);\n        val_blue = Math.map(Blue, 0, 2700, 0, 255);\n\n        if (val_red > 255) val_red = 255;\n        if (val_green > 255) val_green = 255;\n        if (val_blue > 255) val_blue = 255;\n\n        if (val_red == val_green && val_red == val_blue) {\n            val_red = 255;\n            val_green = 255;\n            val_blue == 255;\n        }\n        else if (val_red > val_green && val_red > val_blue) {\n            val_red = 255;\n            val_green /= 2;\n            val_blue /= 2;\n        }\n        else if (val_green > val_red && val_green > val_blue) {\n            val_green = 255;\n            val_red /= 2;\n            val_blue /= 2;\n        }\n        else if (val_blue > val_red && val_blue > val_green) {\n            val_blue = 255;\n            val_red /= 2;\n            val_green /= 2;\n        }\n    }\n\n    //% blockId=ModuleWorld_Sensor_GetRGBValue block=\"GetRGBValue|value %value\"\n    //% blockGap=20\n    //% weight=98\n    //% color=\"#0000cd\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function GetRGBValue(value: enGetRGB): number {\n        if (!initialized) {\n            initColorI2C();\n        }\n        GetRGB();\n        switch (value) {\n            case enGetRGB.GetValueR:\n                return val_red;\n            case enGetRGB.GetValueG:\n                return val_green;\n            case enGetRGB.GetValueB:\n                return val_blue;\n            default:\n                break;\n        }\n        return 0;\n    }\n\n}\nnamespace ModuleWorld_Digital {\n\n    export enum mwDigitalNum {\n        //% blockId=\"P0P1\" block=\"P0P1\"\n        P0P1 = 1,\n        //% blockId=\"P2P3\" block=\"P2P3\"\n        P2P3 = 2,\n        //% blockId=\"P3P4\" block=\"P3P4\"\n        P3P4 = 3,\n        //% blockId=\"P4P5\" block=\"P4P5\"\n        P4P5 = 4,\n        //% blockId=\"P6P7\" block=\"P6P7\"\n        P6P7 = 5,\n        //% blockId=\"P8P9\" block=\"P8P9\"\n        P8P9 = 6,\n        //% blockId=\"P10P11\" block=\"P10P11\"\n        P10P11 = 7,\n        //% blockId=\"P12P13\" block=\"P12P13\"\n        P12P13 = 8,\n        //% blockId=\"P14P15\" block=\"P14P15\"\n        P14P15 = 9,\n        //% blockId=\"P1P10\" block=\"P1P10\"\n        P1P10 = 10\n    }\n\n\n    export enum enObstacle {\n        //% blockId=\"Obstacle\" block=\"Obstacle\"\n        Obstacle = 0,\n        //% blockId=\"NoObstacle\" block=\"NoObstacle\"\n        NoObstacle = 1\n    }\n\n    export enum enPIR {\n        //% blockId=\"NoPIR\" block=\"NoPIR\"\n        NoPIR = 0,\n        //% blockId=\"OPIR\" block=\"OPIR\"\n        OPIR = 1\n    }\n\n    export enum enCollision {\n        //% blockId=\"NoCollision\" block=\"NoCollision\"\n        NoCollision = 0,\n        //% blockId=\"OCollision\" block=\"OCollision\"\n        OCollision = 1\n    }\n\n    export enum enVibration {\n        //% blockId=\"NoVibration\" block=\"NoVibration\"\n        NoVibration = 0,\n        //% blockId=\"OVibration\" block=\"OVibration\"\n        OVibration = 1\n    }\n\n    export enum DHT11Type {\n        //% block=\"temperature(℃)\" enumval=0\n        DHT11_temperature_C,\n\n        //% block=\"temperature(℉)\" enumval=1\n        DHT11_temperature_F,\n\n        //% block=\"humidity(0~100)\" enumval=2\n        DHT11_humidity,\n    }\n    export enum enButton {\n        //% blockId=\"Press\" block=\"Press\"\n        Press = 0,\n        //% blockId=\"Realse\" block=\"Realse\"\n        Realse = 1\n    }\n\n    //% blockId=\"readdht11\" block=\"value of dht11 %dht11type| at pin %value_DNum\"\n    //% weight=100\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5 \n    export function dht11value(dht11type: DHT11Type, value_DNum: mwDigitalNum): number {\n        let dht11pin;\n        if (value_DNum == 1) { dht11pin = DigitalPin.P0; }\n        else if (value_DNum == 2) { dht11pin = DigitalPin.P2; }\n        else if (value_DNum == 3) { dht11pin = DigitalPin.P3; }\n        else if (value_DNum == 4) { dht11pin = DigitalPin.P4; }\n        else if (value_DNum == 5) { dht11pin = DigitalPin.P6; }\n        else if (value_DNum == 6) { dht11pin = DigitalPin.P8; }\n        else if (value_DNum == 7) { dht11pin = DigitalPin.P10; }\n        else if (value_DNum == 8) { dht11pin = DigitalPin.P12; }\n        else if (value_DNum == 9) { dht11pin = DigitalPin.P14; }\n        else if (value_DNum == 10) { dht11pin = DigitalPin.P1; }\n\n        pins.digitalWritePin(dht11pin, 0)\n        basic.pause(18)\n        let i = pins.digitalReadPin(dht11pin)\n        pins.setPull(dht11pin, PinPullMode.PullUp);\n        switch (dht11type) {\n            case 0:\n                let dhtvalue1 = 0;\n                let dhtcounter1 = 0;\n                let dhtcounter1d = 0;\n                while (pins.digitalReadPin(dht11pin) == 1);\n                while (pins.digitalReadPin(dht11pin) == 0);\n                while (pins.digitalReadPin(dht11pin) == 1);\n                for (let i = 0; i <= 32 - 1; i++) {\n                    dhtcounter1d = 0\n                    while (pins.digitalReadPin(dht11pin) == 0) {\n                        dhtcounter1d += 1;\n                    }\n                    dhtcounter1 = 0\n                    while (pins.digitalReadPin(dht11pin) == 1) {\n                        dhtcounter1 += 1;\n                    }\n                    if (i > 15) {\n                        if (dhtcounter1 > dhtcounter1d) {\n                            dhtvalue1 = dhtvalue1 + (1 << (31 - i));\n                        }\n                    }\n                }\n                return ((dhtvalue1 & 0x0000ff00) >> 8);\n                break;\n            case 1:\n                while (pins.digitalReadPin(dht11pin) == 1);\n                while (pins.digitalReadPin(dht11pin) == 0);\n                while (pins.digitalReadPin(dht11pin) == 1);\n                let dhtvalue = 0;\n                let dhtcounter = 0;\n                let dhtcounterd = 0;\n                for (let i = 0; i <= 32 - 1; i++) {\n                    dhtcounterd = 0\n                    while (pins.digitalReadPin(dht11pin) == 0) {\n                        dhtcounterd += 1;\n                    }\n                    dhtcounter = 0\n                    while (pins.digitalReadPin(dht11pin) == 1) {\n                        dhtcounter += 1;\n                    }\n                    if (i > 15) {\n                        if (dhtcounter > dhtcounterd) {\n                            dhtvalue = dhtvalue + (1 << (31 - i));\n                        }\n                    }\n                }\n                return Math.round((((dhtvalue & 0x0000ff00) >> 8) * 9 / 5) + 32);\n                break;\n            case 2:\n                while (pins.digitalReadPin(dht11pin) == 1);\n                while (pins.digitalReadPin(dht11pin) == 0);\n                while (pins.digitalReadPin(dht11pin) == 1);\n\n                let value = 0;\n                let counter = 0;\n                let counterd = 0;\n\n                for (let i = 0; i <= 8 - 1; i++) {\n                    counterd = 0\n                    while (pins.digitalReadPin(dht11pin) == 0) {\n                        counterd += 1;\n                    }\n                    counter = 0\n                    while (pins.digitalReadPin(dht11pin) == 1) {\n                        counter += 1;\n                    }\n                    if (counter > counterd) {\n                        value = value + (1 << (7 - i));\n                    }\n                }\n                return value;\n            default:\n                return 0;\n        }\n    }\n\n\n    //% blockId=ModuleWorld_Digital_Ultrasonic block=\"Ultrasonic|pin %value_DNum\"\n    //% weight=97\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function Ultrasonic(value_DNum: mwDigitalNum): number {\n        //send pulse\n        let Trig, Echo;\n        if (value_DNum == 1) { Trig = DigitalPin.P0; Echo = DigitalPin.P1; }\n        else if (value_DNum == 2) { Trig = DigitalPin.P2; Echo = DigitalPin.P3; }\n        else if (value_DNum == 3) { Trig = DigitalPin.P3; Echo = DigitalPin.P4; }\n        else if (value_DNum == 4) { Trig = DigitalPin.P4; Echo = DigitalPin.P5; }\n        else if (value_DNum == 5) { Trig = DigitalPin.P6; Echo = DigitalPin.P7; }\n        else if (value_DNum == 6) { Trig = DigitalPin.P8; Echo = DigitalPin.P9; }\n        else if (value_DNum == 7) { Trig = DigitalPin.P10; Echo = DigitalPin.P11; }\n        else if (value_DNum == 8) { Trig = DigitalPin.P12; Echo = DigitalPin.P13; }\n        else if (value_DNum == 9) { Trig = DigitalPin.P14; Echo = DigitalPin.P15; }\n        else if (value_DNum == 10) { Trig = DigitalPin.P1; Echo = DigitalPin.P10; }\n\n\n        pins.setPull(Trig, PinPullMode.PullNone);\n        pins.digitalWritePin(Trig, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(Trig, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(Trig, 0);\n\n        //read pulse, maximum distance=500cm\n        const d = pins.pulseIn(Echo, PulseValue.High, 500 * 58);\n\n        return Math.idiv(d, 58);\n    }\n\n    //% blockId=ModuleWorld_Digital_IR block=\"IR|pin %value_DNum|value %value\"\n    //% weight=96\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function IR(value_DNum: mwDigitalNum, value: enObstacle): boolean {\n        let pin;\n        if (value_DNum == 1) { pin = DigitalPin.P0; }\n        else if (value_DNum == 2) { pin = DigitalPin.P2; }\n        else if (value_DNum == 3) { pin = DigitalPin.P3; }\n        else if (value_DNum == 4) { pin = DigitalPin.P4; }\n        else if (value_DNum == 5) { pin = DigitalPin.P6; }\n        else if (value_DNum == 6) { pin = DigitalPin.P8; }\n        else if (value_DNum == 7) { pin = DigitalPin.P10; }\n        else if (value_DNum == 8) { pin = DigitalPin.P12; }\n        else if (value_DNum == 9) { pin = DigitalPin.P14; }\n        else if (value_DNum == 10) { pin = DigitalPin.P1; }\n\n        pins.setPull(pin, PinPullMode.PullUp);\n        return pins.digitalReadPin(pin) == value;\n    }\n\n    //% blockId=ModuleWorld_Digital_PIR block=\"PIR|pin %value_DNum|value %value\"\n    //% weight=96\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function PIR(value_DNum: mwDigitalNum, value: enPIR): boolean {\n        let pin;\n        if (value_DNum == 1) { pin = DigitalPin.P0; }\n        else if (value_DNum == 2) { pin = DigitalPin.P2; }\n        else if (value_DNum == 3) { pin = DigitalPin.P3; }\n        else if (value_DNum == 4) { pin = DigitalPin.P4; }\n        else if (value_DNum == 5) { pin = DigitalPin.P6; }\n        else if (value_DNum == 6) { pin = DigitalPin.P8; }\n        else if (value_DNum == 7) { pin = DigitalPin.P10; }\n        else if (value_DNum == 8) { pin = DigitalPin.P12; }\n        else if (value_DNum == 9) { pin = DigitalPin.P14; }\n        else if (value_DNum == 10) { pin = DigitalPin.P1; }\n\n        pins.setPull(pin, PinPullMode.PullDown);\n        pins.digitalWritePin(pin, 1);\n        return pins.digitalReadPin(pin) == value;\n    }\n\n    //% blockId=ModuleWorld_Digital_Collision block=\"Collision|pin %value_DNum|value %value\"\n    //% weight=3\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function Collision(value_DNum: mwDigitalNum, value: enCollision): boolean {\n\n        let pin;\n        if (value_DNum == 1) { pin = DigitalPin.P0; }\n        else if (value_DNum == 2) { pin = DigitalPin.P2; }\n        else if (value_DNum == 3) { pin = DigitalPin.P3; }\n        else if (value_DNum == 4) { pin = DigitalPin.P4; }\n        else if (value_DNum == 5) { pin = DigitalPin.P6; }\n        else if (value_DNum == 6) { pin = DigitalPin.P8; }\n        else if (value_DNum == 7) { pin = DigitalPin.P10; }\n        else if (value_DNum == 8) { pin = DigitalPin.P12; }\n        else if (value_DNum == 9) { pin = DigitalPin.P14; }\n        else if (value_DNum == 10) { pin = DigitalPin.P1; }\n\n        pins.setPull(pin, PinPullMode.PullUp);\n        return pins.digitalReadPin(pin) == value;\n    }\n\n    //% blockId=ModuleWorld_Digital_Button block=\"Button|pin %value_DNum|value %value\"\n    //% weight=3\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function Button(value_DNum: mwDigitalNum, value: enButton): boolean {\n\n        let pin;\n        if (value_DNum == 1) { pin = DigitalPin.P0; }\n        else if (value_DNum == 2) { pin = DigitalPin.P2; }\n        else if (value_DNum == 3) { pin = DigitalPin.P3; }\n        else if (value_DNum == 4) { pin = DigitalPin.P4; }\n        else if (value_DNum == 5) { pin = DigitalPin.P6; }\n        else if (value_DNum == 6) { pin = DigitalPin.P8; }\n        else if (value_DNum == 7) { pin = DigitalPin.P10; }\n        else if (value_DNum == 8) { pin = DigitalPin.P12; }\n        else if (value_DNum == 9) { pin = DigitalPin.P14; }\n        else if (value_DNum == 10) { pin = DigitalPin.P1; }\n\n        pins.setPull(pin, PinPullMode.PullUp);\n        return pins.digitalReadPin(pin) == value;\n    }\n    //% blockId=ModuleWorld_Digital_Vibration block=\"Vibration|pin %value_DNum|get \"\n    //% weight=1\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function Vibration(value_DNum: mwDigitalNum, handle: () => void): void {\n        let pin;\n        if (value_DNum == 1) { pin = DigitalPin.P0; }\n        else if (value_DNum == 2) { pin = DigitalPin.P2; }\n        else if (value_DNum == 3) { pin = DigitalPin.P3; }\n        else if (value_DNum == 4) { pin = DigitalPin.P4; }\n        else if (value_DNum == 5) { pin = DigitalPin.P6; }\n        else if (value_DNum == 6) { pin = DigitalPin.P8; }\n        else if (value_DNum == 7) { pin = DigitalPin.P10; }\n        else if (value_DNum == 8) { pin = DigitalPin.P12; }\n        else if (value_DNum == 9) { pin = DigitalPin.P14; }\n        else if (value_DNum == 10) { pin = DigitalPin.P1; }\n\n        pins.setPull(pin, PinPullMode.PullUp);\n        pins.setEvents(pin, PinEventType.Edge);\n        control.onEvent(pin, DAL.MICROBIT_PIN_EVT_FALL, handle);\n    }\n\n\n}\n\n//% color=\"#C814B8\" weight=24 icon=\"\\uf1d4\"\nnamespace ModuleWorld_Analog {\n\n    export enum enRocker {\n        //% blockId=\"NoState\" block=\"NoState\"\n        NoState = 0,\n        //% blockId=\"Up\" block=\"Up\"\n        Up,\n        //% blockId=\"Down\" block=\"Down\"\n        Down,\n        //% blockId=\"Left\" block=\"Left\"\n        Left,\n        //% blockId=\"Right\" block=\"Right\"\n        Right\n    }\n\n    export enum mwAnalogNum {\n        //% blockId=\"P0P1\" block=\"P0P1\"\n        AP0P1 = 1,\n        //% blockId=\"P2P3\" block=\"P2P3\"\n        AP2P3 = 2,\n        //% blockId=\"P3P4\" block=\"P3P4\"\n        AP3P4 = 3\n    }\n\n    //% blockId=ModuleWorld_Anaglog_Light block=\"Light|pin %value_ANum\"\n    //% weight=100\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5 \n    export function Light(value_ANum: mwAnalogNum): number {\n        let lightpin;\n        let value: number;\n        if (value_ANum == 1) { lightpin = AnalogPin.P0; }\n        else if (value_ANum == 2) { lightpin = AnalogPin.P2; }\n        else if (value_ANum == 3) { lightpin = AnalogPin.P3; }\n\n        value = 1024 - pins.analogReadPin(lightpin);\n        return value;\n        //return 0;\n    }\n\n    //% blockId=ModuleWorld_Anaglog_Sound block=\"Sound|pin %value_ANum\"\n    //% weight=99\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function Sound(value_ANum: mwAnalogNum): number {\n        let soundpin;\n        let value: number;\n        if (value_ANum == 1) { soundpin = AnalogPin.P0; }\n        else if (value_ANum == 2) { soundpin = AnalogPin.P2; }\n        else if (value_ANum == 3) { soundpin = AnalogPin.P3; }\n\n        value = pins.analogReadPin(soundpin);\n        return value;\n        //return 0;\n    }\n    //% blockId=ModuleWorld_Anaglog_Potentiometer block=\"Potentiometer|pin %value_ANum\"\n    //% weight=2\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOption.columns=5\n    export function Potentiometer(value_ANum: mwAnalogNum): number {\n        let pin;\n        let value: number;\n        if (value_ANum == 1) { pin = AnalogPin.P0; }\n        else if (value_ANum == 2) { pin = AnalogPin.P2; }\n        else if (value_ANum == 3) { pin = AnalogPin.P3; }\n\n        value = pins.analogReadPin(pin);\n        return value;\n    }\n\n    //% blockId=ModuleWorld_Anaglog_Rocker block=\"Rocker|pin %value_ANum|value %value\"\n    //% weight=1\n    //% blockGap=20\n    export function Rocker(value_ANum: mwAnalogNum, value: enRocker): boolean {\n\n        let pin1;\n        let pin2;\n\n        if (value_ANum == 1) { pin1 = AnalogPin.P0; pin2 = AnalogPin.P1; }\n        else if (value_ANum == 2) { pin1 = AnalogPin.P2; pin2 = AnalogPin.P3; }\n        else if (value_ANum == 3) { pin1 = AnalogPin.P3; pin2 = AnalogPin.P4; }\n\n        let x = pins.analogReadPin(pin1);\n        let y = pins.analogReadPin(pin2);\n\n        let now_state = enRocker.NoState;\n\n        if (x < 100) // 左\n        {\n            now_state = enRocker.Left;\n        }\n        else if (x > 700) //右\n        {\n            now_state = enRocker.Right;\n        }\n        else  // 上下\n        {\n            if (y < 100) //下\n            {\n                now_state = enRocker.Down;\n            }\n            else if (y > 700) //上\n            {\n                now_state = enRocker.Up;\n            }\n        }\n        return now_state == value;\n    }\n\n\n\n\n}\n\n//% color=\"#ECA40D\" weight=22 icon=\"\\uf085\"\nnamespace ModuleWorld_PWM {\n\n    export enum enColor {\n        //% blockId=\"OFF\" block=\"OFF\"\n        OFF = 0,\n        //% blockId=\"Red\" block=\"Red\"\n        Red,\n        //% blockId=\"Green\" block=\"Green\"\n        Green,\n        //% blockId=\"Blue\" block=\"Blue\"\n        Blue,\n        //% blockId=\"White\" block=\"White\"\n        White,\n        //% blockId=\"Cyan\" block=\"Cyan\"\n        Cyan,\n        //% blockId=\"Pinkish\" block=\"Pinkish\"\n        Pinkish,\n        //% blockId=\"Yellow\" block=\"Yellow\"\n        Yellow\n    }\n\n    export enum mwDigitalNum {\n        //% blockId=\"P0P1\" block=\"P0P1\"\n        P0P1 = 1,\n        //% blockId=\"P2P3\" block=\"P2P3\"\n        P2P3 = 2,\n        //% blockId=\"P3P4\" block=\"P3P4\"\n        P3P4 = 3,\n        //% blockId=\"P4P5\" block=\"P4P5\"\n        P4P5 = 4,\n        //% blockId=\"P6P7\" block=\"P6P7\"\n        P6P7 = 5,\n        //% blockId=\"P8P9\" block=\"P8P9\"\n        P8P9 = 6,\n        //% blockId=\"P10P11\" block=\"P10P11\"\n        P10P11 = 7,\n        //% blockId=\"P12P13\" block=\"P12P13\"\n        P12P13 = 8,\n        //% blockId=\"P14P15\" block=\"P14P15\"\n        P14P15 = 9,\n        //% blockId=\"P1P10\" block=\"P1P10\"\n        P1P10 = 10\n    }\n\n    export enum mwServoNum {\n        //% blockId=\"P1\" block=\"P1\"\n        P1 = 1,\n        //% blockId=\"P4\" block=\"P4\"\n        P4 = 2,\n        //% blockId=\"P2\" block=\"P2\"\n        P2 = 3,\n        //% blockId=\"P10\" block=\"P10\"\n        P10 = 4\n    }\n\n\n\n    //% blockId=ModuleWorld_PWM_BuzzerPin block=\"Set Buzzer Pin|%value_DNum\"\n    //% weight=99\n    //% blockGap=22\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function BuzzerPin(value_DNum: mwDigitalNum): void {\n        let pinb;\n        if (value_DNum == 1) { pinb = AnalogPin.P0 }\n        else if (value_DNum == 2) { pinb = AnalogPin.P2 }\n        else if (value_DNum == 3) { pinb = AnalogPin.P3 }\n        else if (value_DNum == 4) { pinb = AnalogPin.P4 }\n        else if (value_DNum == 5) { pinb = AnalogPin.P6 }\n        else if (value_DNum == 6) { pinb = AnalogPin.P8 }\n        else if (value_DNum == 7) { pinb = AnalogPin.P10 }\n        else if (value_DNum == 8) { pinb = AnalogPin.P12 }\n        else if (value_DNum == 9) { pinb = AnalogPin.P14 }\n        else if (value_DNum == 10) { pinb = AnalogPin.P1 }\n\n        pins.setAudioPin(pinb);\n    }\n    //% blockId=ModuleWorld_PWM_VibrationMot block=\"Vibration Motor|%value_DNum|speed %speed\"\n    //% weight=80\n    //% blockGap=22\n    //% speed.min=0 speed.max=1023\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function VibrationMot(value_DNum: mwDigitalNum, speed: number): void {\n\n        let pin;\n        if (value_DNum == 1) { pin = AnalogPin.P0; }\n        else if (value_DNum == 2) { pin = AnalogPin.P2; }\n        else if (value_DNum == 3) { pin = AnalogPin.P3; }\n        else if (value_DNum == 4) { pin = AnalogPin.P4; }\n        else if (value_DNum == 5) { pin = AnalogPin.P6; }\n        else if (value_DNum == 6) { pin = AnalogPin.P8; }\n        else if (value_DNum == 7) { pin = AnalogPin.P10; }\n        else if (value_DNum == 8) { pin = AnalogPin.P12; }\n        else if (value_DNum == 9) { pin = AnalogPin.P14; }\n        else if (value_DNum == 10) { pin = AnalogPin.P1; }\n\n        pins.analogWritePin(pin, speed);\n    }\n\n    //% blockId=ModuleWorld_PWM_RGB block=\"RGB|(P12P13P14)|value1 %value1|value2 %value2|value3 %value3\"\n    //% weight=2\n    //% blockGap=20\n    //% value1.min=0 value1.max=255 value2.min=0 value2.max=255 value3.min=0 value3.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function RGB(value1: number, value2: number, value3: number): void {\n\n        pins.analogWritePin(AnalogPin.P13, value1 * 1024 / 256);\n        pins.analogWritePin(AnalogPin.P14, value2 * 1024 / 256);\n        pins.analogWritePin(AnalogPin.P12, value3 * 1024 / 256);\n    }\n\n    //% blockId=ModuleWorld_PWM_RGB2 block=\"RGB|(P12P13P14)|value %value\"\n    //% weight=1\n    //% blockGap=20\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function RGB2(value: enColor): void {\n        let pin1 = DigitalPin.P13;\n        let pin2 = DigitalPin.P14;\n        let pin3 = DigitalPin.P12;\n\n        switch (value) {\n            case enColor.OFF: {\n                pins.digitalWritePin(pin1, 0);\n                pins.digitalWritePin(pin2, 0);\n                pins.digitalWritePin(pin3, 0);\n                break;\n            }\n            case enColor.Red: {\n                pins.digitalWritePin(pin1, 1);\n                pins.digitalWritePin(pin2, 0);\n                pins.digitalWritePin(pin3, 0);\n                break;\n            }\n            case enColor.Green: {\n                pins.digitalWritePin(pin1, 0);\n                pins.digitalWritePin(pin2, 1);\n                pins.digitalWritePin(pin3, 0);\n                break;\n            }\n            case enColor.Blue: {\n                pins.digitalWritePin(pin1, 0);\n                pins.digitalWritePin(pin2, 0);\n                pins.digitalWritePin(pin3, 1);\n                break;\n            }\n            case enColor.White: {\n                pins.digitalWritePin(pin1, 1);\n                pins.digitalWritePin(pin2, 1);\n                pins.digitalWritePin(pin3, 1);\n                break;\n            }\n            case enColor.Cyan: {\n                pins.digitalWritePin(pin1, 0);\n                pins.digitalWritePin(pin2, 1);\n                pins.digitalWritePin(pin3, 1);\n                break;\n            }\n            case enColor.Pinkish: {\n                pins.digitalWritePin(pin1, 1);\n                pins.digitalWritePin(pin2, 0);\n                pins.digitalWritePin(pin3, 1);\n                break;\n            }\n            case enColor.Yellow: {\n                pins.digitalWritePin(pin1, 1);\n                pins.digitalWritePin(pin2, 1);\n                pins.digitalWritePin(pin3, 0);\n                break;\n            }\n        }\n    }\n\n    //% blockId=ModuleWorld_PWM_Servo block=\"Servo(360)|pin %ServoNum|value %value\"\n    //% weight=6\n    //% blockGap=20\n    //% value.min=0 value.max=360\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function Servo(ServoNum: mwServoNum, value: number): void {\n        let pin;\n        if (ServoNum == 1) { pin = AnalogPin.P1; }\n        else if (ServoNum == 2) { pin = AnalogPin.P4; }\n        else if (ServoNum == 3) { pin = AnalogPin.P2; }\n        else if (ServoNum == 4) { pin = AnalogPin.P10; }\n\n        pins.servoSetPulse(pin, Math.map(value, 0, 360, 500, 2500))\n    }\n\n    //% blockId=ModuleWorld_PWM_Servo2 block=\"Servo(270)|pin %ServoNum|value %value\"\n    //% weight=6\n    //% blockGap=20\n    //% value.min=0 value.max=270\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function Servo2(ServoNum: mwServoNum, value: number): void {\n        let pin;\n        if (ServoNum == 1) { pin = AnalogPin.P1; }\n        else if (ServoNum == 2) { pin = AnalogPin.P4; }\n        else if (ServoNum == 3) { pin = AnalogPin.P2; }\n        else if (ServoNum == 4) { pin = AnalogPin.P10; }\n\n        pins.servoSetPulse(pin, Math.map(value, 0, 270, 500, 2500))\n    }\n\n\n\n\n}\nnamespace GHBit {\n\n    const PCA9685_ADD = 0x41;\n    const MODE1 = 0x00;\n    const MODE2 = 0x01;\n    const SUBADR1 = 0x02;\n    const SUBADR2 = 0x03;\n    const SUBADR3 = 0x04;\n\n    const LED0_ON_L = 0x06;\n    const LED0_ON_H = 0x07;\n    const LED0_OFF_L = 0x08;\n    const LED0_OFF_H = 0x09;\n\n    const ALL_LED_ON_L = 0xFA;\n    const ALL_LED_ON_H = 0xFB;\n    const ALL_LED_OFF_L = 0xFC;\n    const ALL_LED_OFF_H = 0xFD;\n\n    const PRESCALE = 0xFE;\n\n    let initialized = false;\n    let yahStrip: neopixel.Strip;\n\n    export enum STepper {\n        //% blockId=\"Stepper\" block=\"foreward\"\n        Stepper = 0,\n        //% blockId=\"Stepper0\" block=\"reversal\"\n        Stepper0,\n        //% blockId=\"Stepper1\" block=\"Stop\"\n        Stepper1\n    }\n    export enum Angle {\n        //% blockId=\"Angle0\" block=\"first gear\"\n        Angle0 = 0,\n        //% blockId=\"Angle1\" block=\"second gear\"\n        Angle1,\n        //% blockId=\"Angle2\" block=\"third gear\"\n        Angle2,\n        //% blockId=\"Angle3\" block=\"forth gear\"\n        Angle3,\n        //% blockId=\"Angle4\" block=\"fifth gear\"\n        Angle4,\n        //% blockId=\"Angle5\" block=\"sixth gear\"\n        Angle5,\n        //% blockId=\"Angle6\" block=\"seventh gear\"\n        Angle6,\n        //% blockId=\"Angle7\" block=\"eighth gear\"\n        Angle7\n    }\n    export enum Beamstate {\n        //% blockId=\"bright\" block=\"Bright\"\n        bright = 1,\n        //% blockId=\"dark\" block=\"Dark\"\n        dark\n    }\n    export enum enMusic {\n\n        dadadum = 0,\n        entertainer,\n        prelude,\n        ode,\n        nyan,\n        ringtone,\n        funk,\n        blues,\n\n        birthday,\n        wedding,\n        funereal,\n        punchline,\n        baddy,\n        chase,\n        ba_ding,\n        wawawawaa,\n        jump_up,\n        jump_down,\n        power_up,\n        power_down\n    }\n\n    export enum enServo {\n\n        S1 = 1,\n        S2,\n        S3,\n        S4\n    }\n\n    export enum Motorshock {\n        //% blockId=\"OFF\" block=\"OFF\"\n        OFF = 0,\n        //% blockId=\"ON\" block=\"ON\"\n        ON\n    }\n\n    export enum speed {\n        //% blockId=\"speed1\" block=\"1\"\n        speed1 = 2000,\n        //% blockId=\"speed2\" block=\"2\"\n        speed2 = 3000,\n        //% blockId=\"speed3\" block=\"3\"\n        speed3 = 4000\n    }\n\n    export enum enRocker {\n        //% blockId=\"Nostate\" block=\"Nostate\"\n        Nostate = 0,\n        //% blockId=\"Up\" block=\"Up\"\n        Up,\n        //% blockId=\"Down\" block=\"Down\"\n        Down,\n        //% blockId=\"Left\" block=\"Left\"\n        Left,\n        //% blockId=\"Right\" block=\"Right\"\n        Right,\n        //% blockId=\"Press\" block=\"Press\"\n        Press\n    }\n\n    export enum enButtonState {\n        //% blockId=\"Press\" block=\"Press\"\n        Press = 0,\n        //% blockId=\"Realse\" block=\"Realse\"\n        Realse = 1\n    }\n\n    export enum enButton {\n\n        B1 = 0,\n        B2,\n        B3,\n        B4\n    }\n\n    export enum enColor {\n        //% blockId=\"OFF\" block=\"OFF\"\n        OFF = 0,\n        //% blockId=\"RED\" block=\"RED\"\n        RED,\n        //% blockId=\"GREEN\" block=\"GREEN\"\n        GREEN,\n        //% blockId=\"BLUE\" block=\"BLUE\"\n        BLUE,\n        //% blockId=\"WHITE\" block=\"WHITE\"\n        WHITE,\n        //% blockId=\"CYAN\" block=\"CYAN\"\n        CYAN,\n        //% blockId=\"PINKISH\" block=\"PINKISH\"\n        PINKISH,\n        //% blockId=\"YELLOW\" block=\"YELLOW\"\n        YELLOW\n    }\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2);\n        buf[0] = reg;\n        buf[1] = value;\n        pins.i2cWriteBuffer(addr, buf);\n    }\n\n    function i2ccmd(addr: number, value: number) {\n        let buf = pins.createBuffer(1);\n        buf[0] = value;\n        pins.i2cWriteBuffer(addr, buf);\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADD, MODE1, 0x00);\n        setFreq(50);\n        initialized = true;\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADD, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADD, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADD, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADD, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADD, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        if (!initialized) {\n            initPCA9685();\n        }\n        let buf = pins.createBuffer(5);\n        buf[0] = LED0_ON_L + 4 * channel;\n        buf[1] = on & 0xff;\n        buf[2] = (on >> 8) & 0xff;\n        buf[3] = off & 0xff;\n        buf[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADD, buf);\n    }\n\n    /**\n     * *****************************************************************\n     * @param index\n     */\n\n    //% blockId=GHBit_RGB_Program block=\"RGB_Program\"\n    //% weight=99\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function RGB_Program(): neopixel.Strip {\n\n        if (!yahStrip) {\n            yahStrip = neopixel.create(DigitalPin.P4, 4, NeoPixelMode.RGB);\n        }\n        return yahStrip;\n    }\n\n    //% blockId=GHBit_RGB_Program_Close block=\"RGB_Program_Close\"\n    //% weight=98\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=12\n    export function RGB_Program_Close(): void {\n        pins.digitalWritePin(DigitalPin.P4, 0);\n        GHBit.RGB_Program().clear();\n        GHBit.RGB_Program().show();\n    }\n\n    //% blockId=GHBit_Min_Motor_Shake block=\"Min_Motor_Shake|value %value\"\n    //% weight=97\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=12\n    export function Min_Motor_Shake(value: Motorshock): void {\n        switch (value) {\n            case Motorshock.ON: {\n                setPwm(0, 0, 4095);\n                break;\n            }\n            case Motorshock.OFF: {\n                setPwm(0, 0, 0);\n                break;\n            }\n        }\n    }\n\n    //% blockId=GHBit_Rocker block=\"Rocker|value %value\"\n    //% weight=96\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=6\n    export function Rocker(value: enRocker): boolean {\n\n        pins.setPull(DigitalPin.P8, PinPullMode.PullUp);\n        let x = pins.analogReadPin(AnalogPin.P1);\n        let y = pins.analogReadPin(AnalogPin.P2);\n        let z = pins.digitalReadPin(DigitalPin.P8);\n        let now_state = enRocker.Nostate;\n\n        if (x < 200) // 上\n        {\n\n            now_state = enRocker.Up;\n\n        }\n        else if (x > 730) //下 900 -> 730\n        {\n\n            now_state = enRocker.Down;\n        }\n        else  // 左右\n        {\n            if (y < 200) //右\n            {\n                now_state = enRocker.Right;\n            }\n            else if (y > 730) //左 900 -> 730\n            {\n                now_state = enRocker.Left;\n            }\n        }\n        if (z == 0)\n            now_state = enRocker.Press;\n        if (now_state == value)\n            return true;\n        else\n            return false;\n\n    }\n\n    //% blockId=GHBit_Button block=\"Button|num %num|value %value\"\n    //% weight=95\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function Button(num: enButton, value: enButtonState): boolean {\n        let temp = false;\n        switch (num) {\n            case enButton.B1: {\n                pins.setPull(DigitalPin.P13, PinPullMode.PullUp);\n                if (pins.digitalReadPin(DigitalPin.P13) == value) {\n                    temp = true;\n                }\n                else {\n                    temp = false;\n                }\n                break;\n            }\n            case enButton.B2: {\n                pins.setPull(DigitalPin.P14, PinPullMode.PullUp);\n                if (pins.digitalReadPin(DigitalPin.P14) == value) {\n                    temp = true;\n                }\n                else {\n                    temp = false;\n                }\n                break;\n            }\n            case enButton.B3: {\n                pins.setPull(DigitalPin.P15, PinPullMode.PullUp);\n                if (pins.digitalReadPin(DigitalPin.P15) == value) {\n                    temp = true;\n                }\n                else {\n                    temp = false;\n                }\n                break;\n            }\n            case enButton.B4: {\n                pins.setPull(DigitalPin.P16, PinPullMode.PullUp);\n                if (pins.digitalReadPin(DigitalPin.P16) == value) {\n                    temp = true;\n                }\n                else {\n                    temp = false;\n                }\n                break;\n            }\n        }\n        return temp;\n    }\n\n\n\n    //% blockId=GHBit_Music_Handle block=\"Music_Handle|%index\"\n    //% weight=92\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Music_Handle(index: enMusic): void {\n        switch (index) {\n            case enMusic.dadadum: music.beginMelody(music.builtInMelody(Melodies.Dadadadum), MelodyOptions.Once); break;\n            case enMusic.birthday: music.beginMelody(music.builtInMelody(Melodies.Birthday), MelodyOptions.Once); break;\n            case enMusic.entertainer: music.beginMelody(music.builtInMelody(Melodies.Entertainer), MelodyOptions.Once); break;\n            case enMusic.prelude: music.beginMelody(music.builtInMelody(Melodies.Prelude), MelodyOptions.Once); break;\n            case enMusic.ode: music.beginMelody(music.builtInMelody(Melodies.Ode), MelodyOptions.Once); break;\n            case enMusic.nyan: music.beginMelody(music.builtInMelody(Melodies.Nyan), MelodyOptions.Once); break;\n            case enMusic.ringtone: music.beginMelody(music.builtInMelody(Melodies.Ringtone), MelodyOptions.Once); break;\n            case enMusic.funk: music.beginMelody(music.builtInMelody(Melodies.Funk), MelodyOptions.Once); break;\n            case enMusic.blues: music.beginMelody(music.builtInMelody(Melodies.Blues), MelodyOptions.Once); break;\n            case enMusic.wedding: music.beginMelody(music.builtInMelody(Melodies.Wedding), MelodyOptions.Once); break;\n            case enMusic.funereal: music.beginMelody(music.builtInMelody(Melodies.Funeral), MelodyOptions.Once); break;\n            case enMusic.punchline: music.beginMelody(music.builtInMelody(Melodies.Punchline), MelodyOptions.Once); break;\n            case enMusic.baddy: music.beginMelody(music.builtInMelody(Melodies.Baddy), MelodyOptions.Once); break;\n            case enMusic.chase: music.beginMelody(music.builtInMelody(Melodies.Chase), MelodyOptions.Once); break;\n            case enMusic.ba_ding: music.beginMelody(music.builtInMelody(Melodies.BaDing), MelodyOptions.Once); break;\n            case enMusic.wawawawaa: music.beginMelody(music.builtInMelody(Melodies.Wawawawaa), MelodyOptions.Once); break;\n            case enMusic.jump_up: music.beginMelody(music.builtInMelody(Melodies.JumpUp), MelodyOptions.Once); break;\n            case enMusic.jump_down: music.beginMelody(music.builtInMelody(Melodies.JumpDown), MelodyOptions.Once); break;\n            case enMusic.power_up: music.beginMelody(music.builtInMelody(Melodies.PowerUp), MelodyOptions.Once); break;\n            case enMusic.power_down: music.beginMelody(music.builtInMelody(Melodies.PowerDown), MelodyOptions.Once); break;\n        }\n    }\n\n    //% blockId=GHBit_Servo_Handle block=\"Servo_Handle|num %num|value %value\"\n    //% weight=91\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% num.min=1 num.max=4 value.min=0 value.max=180\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=9\n    export function Servo_Handle(num: enServo, value: number): void {\n\n        // 50hz: 20,000 us\n        let us = (value * 1800 / 180 + 600); // 0.6 ~ 2.4\n        let pwm = us * 4096 / 20000;\n        setPwm(num + 8, 0, pwm);\n\n    }\n\n    //% blockId=GHBit_Ultrasonic_Handle block=\"ultrasonic return distance(cm)\"\n    //% color=\"#C814B8\"\n    //% weight=90\n    //% blockGap=10\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Ultrasonic_Handle(): number {\n\n        // send pulse\n        pins.setPull(DigitalPin.P12, PinPullMode.PullNone)\n        pins.digitalWritePin(DigitalPin.P12, 0)\n        control.waitMicros(4)\n        pins.digitalWritePin(DigitalPin.P12, 1)\n        control.waitMicros(15)\n        pins.digitalWritePin(DigitalPin.P12, 0)\n        const d = pins.pulseIn(DigitalPin.P11, PulseValue.High, 500 * 40);\n        return Math.idiv(d, 40)\n    }\n\n    //% blockId=GHBit_Ultrasonic_Handle_V2 block=\"ultrasonic_V2 return distance(cm)\"\n    //% color=\"#C814B8\"\n    //% weight=90\n    //% blockGap=10\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Ultrasonic_Handle_V2(): number {\n\n        // send pulse\n        pins.setPull(DigitalPin.P12, PinPullMode.PullNone)\n        pins.digitalWritePin(DigitalPin.P12, 0)\n        control.waitMicros(4)\n        pins.digitalWritePin(DigitalPin.P12, 1)\n        control.waitMicros(15)\n        pins.digitalWritePin(DigitalPin.P12, 0)\n        const d = pins.pulseIn(DigitalPin.P11, PulseValue.High, 500 * 58);\n        return Math.idiv(d, 58)\n    }\n\n    //% blockId=GHBit_RGB_Colorful block=\"RGB_Colorful|%value\"\n    //% weight=89\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function RGB_Colorful(value: enColor): void {\n        switch (value) {\n            case enColor.OFF: {\n                setPwm(15, 0, 0);\n                setPwm(14, 0, 0);\n                setPwm(13, 0, 0);\n                break;\n            }\n            case enColor.RED: {\n                setPwm(15, 0, 4095);\n                setPwm(14, 0, 0);\n                setPwm(13, 0, 0);\n                break;\n            }\n            case enColor.GREEN: {\n                setPwm(15, 0, 0);\n                setPwm(14, 0, 4095);\n                setPwm(13, 0, 0);\n                break;\n            }\n            case enColor.BLUE: {\n                setPwm(15, 0, 0);\n                setPwm(14, 0, 0);\n                setPwm(13, 0, 4095);\n                break;\n            }\n            case enColor.WHITE: {\n                setPwm(15, 0, 4095);\n                setPwm(14, 0, 4095);\n                setPwm(13, 0, 4095);\n                break;\n            }\n            case enColor.CYAN: {\n                setPwm(15, 0, 0);\n                setPwm(14, 0, 4095);\n                setPwm(13, 0, 4095);\n                break;\n            }\n            case enColor.PINKISH: {\n                setPwm(15, 0, 4095);\n                setPwm(14, 0, 0);\n                setPwm(13, 0, 4095);\n                break;\n            }\n            case enColor.YELLOW: {\n                setPwm(15, 0, 4095);\n                setPwm(14, 0, 4095);\n                setPwm(13, 0, 0);\n                break;\n            }\n        }\n    }\n\n    //% blockId=GHBit_Stepper_Motor block=\"Stepper_Motor|value %value|value1 %value1\"\n    //% weight=88\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=12\n    export function Stepper_Motor(value: STepper, value1: speed): void {\n        let a = 64;\n        switch (value) {\n            case STepper.Stepper: {\n                while (a) {\n                    setPwm(1, 0, 4095);\n                    setPwm(2, 0, 4095);\n                    setPwm(3, 0, 0);\n                    setPwm(4, 0, 0);\n                    control.waitMicros(value1);\n                    setPwm(1, 0, 0);\n                    setPwm(2, 0, 4095);\n                    setPwm(3, 0, 4095);\n                    setPwm(4, 0, 0);\n                    control.waitMicros(value1);\n                    setPwm(1, 0, 0);\n                    setPwm(2, 0, 0);\n                    setPwm(3, 0, 4095);\n                    setPwm(4, 0, 4095);\n                    control.waitMicros(value1);\n                    setPwm(1, 0, 4095);\n                    setPwm(2, 0, 0);\n                    setPwm(3, 0, 0);\n                    setPwm(4, 0, 4095);\n                    control.waitMicros(value1);\n                    a--;\n                }\n                a = 0;\n                break;\n            }\n            case STepper.Stepper0: {\n                while (a) {\n                    setPwm(1, 0, 0);\n                    setPwm(2, 0, 0);\n                    setPwm(3, 0, 4095);\n                    setPwm(4, 0, 4095);\n                    control.waitMicros(value1);\n                    setPwm(1, 0, 0);\n                    setPwm(2, 0, 4095);\n                    setPwm(3, 0, 4095);\n                    setPwm(4, 0, 0);\n                    control.waitMicros(value1);\n                    setPwm(1, 0, 4095);\n                    setPwm(2, 0, 4095);\n                    setPwm(3, 0, 0);\n                    setPwm(4, 0, 0);\n                    control.waitMicros(value1);\n                    setPwm(1, 0, 4095);\n                    setPwm(2, 0, 0);\n                    setPwm(3, 0, 0);\n                    setPwm(4, 0, 4095);\n                    control.waitMicros(value1);\n                    a--;\n                }\n                a = 0;\n                break;\n            }\n            case STepper.Stepper1: {\n                setPwm(1, 0, 0);\n                setPwm(2, 0, 0);\n                setPwm(3, 0, 0);\n                setPwm(4, 0, 0);\n                break;\n            }\n        }\n    }\n    //% blockId=GHBit_Min_Motor block=\"Min_Motor|value %value\"\n    //% weight=87\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=12\n    export function Min_Motor(value: Angle): void {\n        switch (value) {\n            case Angle.Angle0: {\n                setPwm(7, 0, 0);\n                setPwm(8, 0, 0);\n                break;\n            }\n            case Angle.Angle1: {\n                setPwm(7, 0, 600);\n                setPwm(8, 0, 0);\n                break;\n            }\n            case Angle.Angle2: {\n                setPwm(7, 0, 1200);\n                setPwm(8, 0, 0);\n                break;\n            }\n            case Angle.Angle3: {\n                setPwm(7, 0, 1800);\n                setPwm(8, 0, 0);\n                break;\n            }\n            case Angle.Angle4: {\n                setPwm(7, 0, 2400);\n                setPwm(8, 0, 0);\n                break;\n            }\n            case Angle.Angle5: {\n                setPwm(7, 0, 3000);\n                setPwm(8, 0, 0);\n                break;\n            }\n            case Angle.Angle6: {\n                setPwm(7, 0, 3600);\n                setPwm(8, 0, 0);\n                break;\n            }\n            case Angle.Angle7: {\n                setPwm(7, 0, 4095);\n                setPwm(8, 0, 0);\n                break;\n            }\n        }\n    }\n    //% blockId=GHBit_Rotate block=\"Rotate|value %value\"\n    //% weight=86\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=6\n    export function Rotate(value: Angle): boolean {\n\n        let y = pins.analogReadPin(AnalogPin.P3);\n        let a = false;\n        switch (value) {\n            case Angle.Angle0: {\n                if (y < 128)\n                    a = true;\n                else\n                    a = false;\n                break;\n            }\n            case Angle.Angle1: {\n                if (y < 254 && y > 127)\n                    a = true;\n                else\n                    a = false;\n                break;\n            }\n            case Angle.Angle2: {\n                if (y < 381 && y > 253)\n                    a = true;\n                else\n                    a = false;\n                break;\n            }\n            case Angle.Angle3: {\n                if (y < 508 && y > 381)\n                    a = true;\n                else\n                    a = false;\n                break;\n            }\n            case Angle.Angle4: {\n                if (y < 635 && y > 508)\n                    a = true;\n                else\n                    a = false;\n                break;\n            }\n            case Angle.Angle5: {\n                if (y < 762 && y > 634)\n                    a = true;\n                else\n                    a = false;\n                break;\n            }\n            case Angle.Angle6: {\n                if (y < 889 && y > 761)\n                    a = true;\n                else\n                    a = false;\n                break;\n            }\n            case Angle.Angle7: {\n                if (y > 888)\n                    a = true;\n                else\n                    a = false;\n                break;\n            }\n        }\n        return a;\n    }\n\n    //% blockId=GHBit_Beam block=\"Beam|value %value\"\n    //% weight=85\n    //% blockGap=10\n    //% color=\"#C814B8\"\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=6\n    export function Beam(value: Beamstate): boolean {\n\n        pins.setPull(DigitalPin.P10, PinPullMode.PullUp);\n        let x = pins.analogReadPin(AnalogPin.P10);\n        if (x < 700) // 亮\n        {\n            if (value == Beamstate.bright) {\n                return true;\n            }\n            else {\n\n                return false;\n            }\n        }\n        else {\n\n            if (value == Beamstate.dark) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n    }\n\n\n}"],[1,"basic.forever(function () {\n\t\n})\n"]],"start1":0,"start2":0,"length1":99178,"length2":33}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"neopixel\": \"github:microsoft/pxt-neopixel#v0.7.5\""],[0,"\n   "]],"start1":150,"start2":150,"length1":68,"length2":8},{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":242,"start2":242,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1721714043464,"editorVersion":"7.0.9","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"h\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1721716862146,"editorVersion":"7.0.9","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>","main.ts":"","README.md":"","pxt.json":"{\n    \"name\": \"h\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}}],"shares":[]}